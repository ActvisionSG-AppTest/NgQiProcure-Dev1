import {
    mergeMap as _observableMergeMap,
    catchError as _observableCatch
} from "rxjs/operators";
import {
    Observable,
    throwError as _observableThrow,
    of as _observableOf
} from "rxjs";
import { Injectable, Inject, Optional, InjectionToken } from "@angular/core";
import {
    HttpClient,
    HttpHeaders,
    HttpResponse,
    HttpResponseBase
} from "@angular/common/http";
import * as moment from "moment";
//import { NameValueOfString } from './service-proxies';

export const API_BASE_CUSTOM_URL = new InjectionToken<string>("API_BASE_URL");

//#region Account

@Injectable()
export class AccountsCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param isPersonalFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param remarkFilter (optional) 
     * @param codeFilter (optional) 
     * @param emailFilter (optional) 
     * @param userNameFilter (optional) 
     * @param passwordFilter (optional) 
     * @param teamNameFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, isPersonalFilter: number | undefined, isActiveFilter: number | undefined, remarkFilter: string | undefined, codeFilter: string | undefined, emailFilter: string | undefined, userNameFilter: string | undefined, passwordFilter: string | undefined, teamNameFilter: string | undefined, sysStatusNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAccountForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (isPersonalFilter === null)
            throw new Error("The parameter 'isPersonalFilter' cannot be null.");
        else if (isPersonalFilter !== undefined)
            url_ += "IsPersonalFilter=" + encodeURIComponent("" + isPersonalFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (emailFilter === null)
            throw new Error("The parameter 'emailFilter' cannot be null.");
        else if (emailFilter !== undefined)
            url_ += "EmailFilter=" + encodeURIComponent("" + emailFilter) + "&"; 
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (passwordFilter === null)
            throw new Error("The parameter 'passwordFilter' cannot be null.");
        else if (passwordFilter !== undefined)
            url_ += "PasswordFilter=" + encodeURIComponent("" + passwordFilter) + "&"; 
        if (teamNameFilter === null)
            throw new Error("The parameter 'teamNameFilter' cannot be null.");
        else if (teamNameFilter !== undefined)
            url_ += "TeamNameFilter=" + encodeURIComponent("" + teamNameFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAccountForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAccountForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAccountForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAccountForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAccountForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAccountForView(id: number | undefined): Observable<GetAccountForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAccountForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAccountForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccountForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountForView(response: HttpResponseBase): Observable<GetAccountForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAccountForEdit(id: number | undefined): Observable<GetAccountForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAccountForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAccountForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccountForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountForEdit(response: HttpResponseBase): Observable<GetAccountForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAccountDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param isPersonalFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param remarkFilter (optional) 
     * @param codeFilter (optional) 
     * @param emailFilter (optional) 
     * @param userNameFilter (optional) 
     * @param passwordFilter (optional) 
     * @param teamNameFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @return Success
     */
    getAccountsToExcel(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, isPersonalFilter: number | undefined, isActiveFilter: number | undefined, remarkFilter: string | undefined, codeFilter: string | undefined, emailFilter: string | undefined, userNameFilter: string | undefined, passwordFilter: string | undefined, teamNameFilter: string | undefined, sysStatusNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAccountsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (isPersonalFilter === null)
            throw new Error("The parameter 'isPersonalFilter' cannot be null.");
        else if (isPersonalFilter !== undefined)
            url_ += "IsPersonalFilter=" + encodeURIComponent("" + isPersonalFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (codeFilter === null)
            throw new Error("The parameter 'codeFilter' cannot be null.");
        else if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (emailFilter === null)
            throw new Error("The parameter 'emailFilter' cannot be null.");
        else if (emailFilter !== undefined)
            url_ += "EmailFilter=" + encodeURIComponent("" + emailFilter) + "&"; 
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (passwordFilter === null)
            throw new Error("The parameter 'passwordFilter' cannot be null.");
        else if (passwordFilter !== undefined)
            url_ += "PasswordFilter=" + encodeURIComponent("" + passwordFilter) + "&"; 
        if (teamNameFilter === null)
            throw new Error("The parameter 'teamNameFilter' cannot be null.");
        else if (teamNameFilter !== undefined)
            url_ += "TeamNameFilter=" + encodeURIComponent("" + teamNameFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTeamForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAccountTeamLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAllTeamForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeamForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeamForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountTeamLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountTeamLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTeamForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAccountTeamLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAccountTeamLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountTeamLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysStatusForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfAccountSysStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Accounts/GetAllSysStatusForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountSysStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountSysStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAccountSysStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAccountSysStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountSysStatusLookupTableDto>(<any>null);
    }
}

export class AccountDto implements IAccountDto {
    name!: string | undefined;
    description!: string | undefined;
    isPersonal!: boolean;
    isActive!: boolean;
    remark!: string | undefined;
    code!: string | undefined;
    email!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;
    teamId!: number | undefined;
    sysStatusId!: number | undefined;
    id!: number;

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.isPersonal = data["isPersonal"];
            this.isActive = data["isActive"];
            this.remark = data["remark"];
            this.code = data["code"];
            this.email = data["email"];
            this.userName = data["userName"];
            this.password = data["password"];
            this.teamId = data["teamId"];
            this.sysStatusId = data["sysStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["isPersonal"] = this.isPersonal;
        data["isActive"] = this.isActive;
        data["remark"] = this.remark;
        data["code"] = this.code;
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["teamId"] = this.teamId;
        data["sysStatusId"] = this.sysStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAccountDto {
    name: string | undefined;
    description: string | undefined;
    isPersonal: boolean;
    isActive: boolean;
    remark: string | undefined;
    code: string | undefined;
    email: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    teamId: number | undefined;
    sysStatusId: number | undefined;
    id: number;
}

export class GetAccountForViewDto implements IGetAccountForViewDto {
    account!: AccountDto;
    teamName!: string | undefined;
    sysStatusName!: string | undefined;

    constructor(data?: IGetAccountForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.account = data["account"] ? AccountDto.fromJS(data["account"]) : <any>undefined;
            this.teamName = data["teamName"];
            this.sysStatusName = data["sysStatusName"];
        }
    }

    static fromJS(data: any): GetAccountForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["teamName"] = this.teamName;
        data["sysStatusName"] = this.sysStatusName;
        return data; 
    }
}

export interface IGetAccountForViewDto {
    account: AccountDto;
    teamName: string | undefined;
    sysStatusName: string | undefined;
}

export class PagedResultDtoOfGetAccountForViewDto implements IPagedResultDtoOfGetAccountForViewDto {
    totalCount!: number;
    items!: GetAccountForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAccountForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAccountForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAccountForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAccountForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAccountForViewDto {
    totalCount: number;
    items: GetAccountForViewDto[] | undefined;
}

export class CreateOrEditAccountDto implements ICreateOrEditAccountDto {
    name!: string | undefined;
    description!: string | undefined;
    isPersonal!: boolean;
    isActive!: boolean;
    remark!: string | undefined;
    code!: string | undefined;
    email!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;
    teamId!: number | undefined;
    sysStatusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.isPersonal = data["isPersonal"];
            this.isActive = data["isActive"];
            this.remark = data["remark"];
            this.code = data["code"];
            this.email = data["email"];
            this.userName = data["userName"];
            this.password = data["password"];
            this.teamId = data["teamId"];
            this.sysStatusId = data["sysStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["isPersonal"] = this.isPersonal;
        data["isActive"] = this.isActive;
        data["remark"] = this.remark;
        data["code"] = this.code;
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["teamId"] = this.teamId;
        data["sysStatusId"] = this.sysStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAccountDto {
    name: string | undefined;
    description: string | undefined;
    isPersonal: boolean;
    isActive: boolean;
    remark: string | undefined;
    code: string | undefined;
    email: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    teamId: number | undefined;
    sysStatusId: number | undefined;
    id: number | undefined;
}

export class GetAccountForEditOutput implements IGetAccountForEditOutput {
    account!: CreateOrEditAccountDto;
    teamName!: string | undefined;
    sysStatusName!: string | undefined;

    constructor(data?: IGetAccountForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.account = data["account"] ? CreateOrEditAccountDto.fromJS(data["account"]) : <any>undefined;
            this.teamName = data["teamName"];
            this.sysStatusName = data["sysStatusName"];
        }
    }

    static fromJS(data: any): GetAccountForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["teamName"] = this.teamName;
        data["sysStatusName"] = this.sysStatusName;
        return data; 
    }
}

export interface IGetAccountForEditOutput {
    account: CreateOrEditAccountDto;
    teamName: string | undefined;
    sysStatusName: string | undefined;
}


export class AccountTeamLookupTableDto implements IAccountTeamLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IAccountTeamLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AccountTeamLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTeamLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAccountTeamLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfAccountTeamLookupTableDto implements IPagedResultDtoOfAccountTeamLookupTableDto {
    totalCount!: number;
    items!: AccountTeamLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAccountTeamLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AccountTeamLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAccountTeamLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAccountTeamLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAccountTeamLookupTableDto {
    totalCount: number;
    items: AccountTeamLookupTableDto[] | undefined;
}

export class AccountSysStatusLookupTableDto implements IAccountSysStatusLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IAccountSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AccountSysStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAccountSysStatusLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfAccountSysStatusLookupTableDto implements IPagedResultDtoOfAccountSysStatusLookupTableDto {
    totalCount!: number;
    items!: AccountSysStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAccountSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AccountSysStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAccountSysStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAccountSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAccountSysStatusLookupTableDto {
    totalCount: number;
    items: AccountSysStatusLookupTableDto[] | undefined;
}

//#endregion Account

//#region Additional Service
@Injectable()
export class CategoriesCustomServiceByServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    GetCategoriesNameValue(): Observable<NameValueServiceOfString[]> {
        let url_ =
            this.baseUrl +
            "/api/services/app/Categories/GetCategoriesNameValue";

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCategories(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCategories(<any>response_);
                        } catch (e) {
                            return <Observable<NameValueServiceOfString[]>>(
                                (<any>_observableThrow(e))
                            );
                        }
                    } else
                        return <Observable<NameValueServiceOfString[]>>(
                            (<any>_observableThrow(response_))
                        );
                })
            );
    }

    protected processGetCategories(
        response: HttpResponseBase
    ): Observable<NameValueServiceOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200)
                            result200!.push(
                                NameValueServiceOfString.fromJS(item)
                            );
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<NameValueServiceOfString[]>(<any>null);
    }
}

//#endregion

//#region Approval
@Injectable()
export class ApprovalsCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param maxRankNoFilter (optional)
     * @param minRankNoFilter (optional)
     * @param maxAmountFilter (optional)
     * @param minAmountFilter (optional)
     * @param sysRefTenantIdFilter (optional)
     * @param teamNameFilter (optional)
     * @param projectNameFilter (optional)
     * @param accountNameFilter (optional)
     * @param userNameFilter (optional)
     * @param sysStatusNameFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(
        filter: string | undefined,
        maxRankNoFilter: number | undefined,
        minRankNoFilter: number | undefined,
        maxAmountFilter: number | undefined,
        minAmountFilter: number | undefined,
        sysRefTenantIdFilter: string | undefined,
        teamNameFilter: string | undefined,
        projectNameFilter: string | undefined,
        accountNameFilter: string | undefined,
        userNameFilter: string | undefined,
        sysStatusNameFilter: string | undefined,
        refCodeFilter: string | undefined,
        sorting: string | undefined,
        skipCount: number | undefined,
        maxResultCount: number | undefined
    ): Observable<PagedResultDtoOfGetApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Approvals/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRankNoFilter === null)
            throw new Error("The parameter 'maxRankNoFilter' cannot be null.");
        else if (maxRankNoFilter !== undefined)
            url_ +=
                "MaxRankNoFilter=" +
                encodeURIComponent("" + maxRankNoFilter) +
                "&";
        if (minRankNoFilter === null)
            throw new Error("The parameter 'minRankNoFilter' cannot be null.");
        else if (minRankNoFilter !== undefined)
            url_ +=
                "MinRankNoFilter=" +
                encodeURIComponent("" + minRankNoFilter) +
                "&";
        if (maxAmountFilter === null)
            throw new Error("The parameter 'maxAmountFilter' cannot be null.");
        else if (maxAmountFilter !== undefined)
            url_ +=
                "MaxAmountFilter=" +
                encodeURIComponent("" + maxAmountFilter) +
                "&";
        if (minAmountFilter === null)
            throw new Error("The parameter 'minAmountFilter' cannot be null.");
        else if (minAmountFilter !== undefined)
            url_ +=
                "MinAmountFilter=" +
                encodeURIComponent("" + minAmountFilter) +
                "&";
        if (sysRefTenantIdFilter === null)
            throw new Error(
                "The parameter 'sysRefTenantIdFilter' cannot be null."
            );
        else if (sysRefTenantIdFilter !== undefined)
            url_ +=
                "SysRefTenantIdFilter=" +
                encodeURIComponent("" + sysRefTenantIdFilter) +
                "&";
        if (teamNameFilter === null)
            throw new Error("The parameter 'teamNameFilter' cannot be null.");
        else if (teamNameFilter !== undefined)
            url_ +=
                "TeamNameFilter=" +
                encodeURIComponent("" + teamNameFilter) +
                "&";
        if (projectNameFilter === null)
            throw new Error(
                "The parameter 'projectNameFilter' cannot be null."
            );
        else if (projectNameFilter !== undefined)
            url_ +=
                "ProjectNameFilter=" +
                encodeURIComponent("" + projectNameFilter) +
                "&";
        if (accountNameFilter === null)
            throw new Error(
                "The parameter 'accountNameFilter' cannot be null."
            );
        else if (accountNameFilter !== undefined)
            url_ +=
                "AccountNameFilter=" +
                encodeURIComponent("" + accountNameFilter) +
                "&";
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ +=
                "UserNameFilter=" +
                encodeURIComponent("" + userNameFilter) +
                "&";
        if (sysStatusNameFilter === null)
            throw new Error(
                "The parameter 'sysStatusNameFilter' cannot be null."
            );
        else if (sysStatusNameFilter !== undefined)
            url_ +=
                "SysStatusNameFilter=" +
                encodeURIComponent("" + sysStatusNameFilter) +
                "&";
        if (refCodeFilter === null)
            throw new Error("The parameter 'refCodeFilter' cannot be null.");
        else if (refCodeFilter !== undefined)
            url_ +=
                "RefCodeFilter=" + encodeURIComponent("" + refCodeFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ +=
                "MaxResultCount=" +
                encodeURIComponent("" + maxResultCount) +
                "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetAll(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetAll(<any>response_);
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfGetApprovalForViewDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<PagedResultDtoOfGetApprovalForViewDto>
                        >(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetAll(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfGetApprovalForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfGetApprovalForViewDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfGetApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getApprovalForView(id: number | undefined): Observable<GetApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Approvals/GetApprovalForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovalForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovalForView(<any>response_);
                } catch (e) {
                    return <Observable<GetApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApprovalForView(response: HttpResponseBase): Observable<GetApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetApprovalForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getApprovalForEdit(id: number | undefined): Observable<GetApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Approvals/GetApprovalForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetApprovalForEdit(response: HttpResponseBase): Observable<GetApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetApprovalForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApprovalForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditApprovalDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Approvals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Approvals/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxRankNoFilter (optional) 
     * @param minRankNoFilter (optional) 
     * @param maxAmountFilter (optional) 
     * @param minAmountFilter (optional) 
     * @param sysRefTenantIdFilter (optional) 
     * @param teamNameFilter (optional) 
     * @param projectNameFilter (optional) 
     * @param accountNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @return Success
     */
    getApprovalsToExcel(filter: string | undefined, maxRankNoFilter: number | undefined, minRankNoFilter: number | undefined, maxAmountFilter: number | undefined, minAmountFilter: number | undefined, sysRefTenantIdFilter: string | undefined, teamNameFilter: string | undefined, projectNameFilter: string | undefined, accountNameFilter: string | undefined, userNameFilter: string | undefined, sysStatusNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Approvals/GetApprovalsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxRankNoFilter === null)
            throw new Error("The parameter 'maxRankNoFilter' cannot be null.");
        else if (maxRankNoFilter !== undefined)
            url_ += "MaxRankNoFilter=" + encodeURIComponent("" + maxRankNoFilter) + "&"; 
        if (minRankNoFilter === null)
            throw new Error("The parameter 'minRankNoFilter' cannot be null.");
        else if (minRankNoFilter !== undefined)
            url_ += "MinRankNoFilter=" + encodeURIComponent("" + minRankNoFilter) + "&"; 
        if (maxAmountFilter === null)
            throw new Error("The parameter 'maxAmountFilter' cannot be null.");
        else if (maxAmountFilter !== undefined)
            url_ += "MaxAmountFilter=" + encodeURIComponent("" + maxAmountFilter) + "&"; 
        if (minAmountFilter === null)
            throw new Error("The parameter 'minAmountFilter' cannot be null.");
        else if (minAmountFilter !== undefined)
            url_ += "MinAmountFilter=" + encodeURIComponent("" + minAmountFilter) + "&"; 
        if (sysRefTenantIdFilter === null)
            throw new Error("The parameter 'sysRefTenantIdFilter' cannot be null.");
        else if (sysRefTenantIdFilter !== undefined)
            url_ += "SysRefTenantIdFilter=" + encodeURIComponent("" + sysRefTenantIdFilter) + "&"; 
        if (teamNameFilter === null)
            throw new Error("The parameter 'teamNameFilter' cannot be null.");
        else if (teamNameFilter !== undefined)
            url_ += "TeamNameFilter=" + encodeURIComponent("" + teamNameFilter) + "&"; 
        if (projectNameFilter === null)
            throw new Error("The parameter 'projectNameFilter' cannot be null.");
        else if (projectNameFilter !== undefined)
            url_ += "ProjectNameFilter=" + encodeURIComponent("" + projectNameFilter) + "&"; 
        if (accountNameFilter === null)
            throw new Error("The parameter 'accountNameFilter' cannot be null.");
        else if (accountNameFilter !== undefined)
            url_ += "AccountNameFilter=" + encodeURIComponent("" + accountNameFilter) + "&"; 
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovalsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovalsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApprovalsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysRefForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfApprovalSysRefLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Approvals/GetAllSysRefForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysRefForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysRefForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApprovalSysRefLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApprovalSysRefLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysRefForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfApprovalSysRefLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApprovalSysRefLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApprovalSysRefLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTeamForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfApprovalTeamLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Approvals/GetAllTeamForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeamForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeamForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApprovalTeamLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApprovalTeamLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTeamForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfApprovalTeamLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApprovalTeamLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApprovalTeamLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProjectForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfApprovalProjectLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Approvals/GetAllProjectForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjectForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjectForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApprovalProjectLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApprovalProjectLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProjectForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfApprovalProjectLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApprovalProjectLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApprovalProjectLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAccountForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfApprovalAccountLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Approvals/GetAllAccountForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccountForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApprovalAccountLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApprovalAccountLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAccountForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfApprovalAccountLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApprovalAccountLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApprovalAccountLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfApprovalUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Approvals/GetAllUserForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApprovalUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApprovalUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfApprovalUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApprovalUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApprovalUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysStatusForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfApprovalSysStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Approvals/GetAllSysStatusForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApprovalSysStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApprovalSysStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfApprovalSysStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApprovalSysStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApprovalSysStatusLookupTableDto>(<any>null);
    }

    submitNewTeamForApproval(
        body: SubmitNewTeamForApprovalInput | undefined
    ): Observable<RequestOutput> {
        let url_ =
            this.baseUrl +
            "/api/services/app/Approvals/SubmitNewTeamForApproval";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json"
            })
        };

        return this.http
            .request("post", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSubmitNewTeamForApproval(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSubmitNewTeamForApproval(
                                <any>response_
                            );
                        } catch (e) {
                            return <Observable<RequestOutput>>(
                                (<any>_observableThrow(e))
                            );
                        }
                    } else
                        return <Observable<RequestOutput>>(
                            (<any>_observableThrow(response_))
                        );
                })
            );
    }

    protected processSubmitNewTeamForApproval(
        response: HttpResponseBase
    ): Observable<RequestOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = RequestOutput.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<RequestOutput>(<any>null);
    }
}

export class RequestOutput implements IRequestOutput {
    status!: boolean;
    statusMessage!: string | undefined;

    constructor(data?: IRequestOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.statusMessage = data["statusMessage"];
        }
    }

    static fromJS(data: any): RequestOutput {
        data = typeof data === "object" ? data : {};
        let result = new RequestOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["status"] = this.status;
        data["statusMessage"] = this.statusMessage;
        return data;
    }
}

export interface IRequestOutput {
    status: boolean;
    statusMessage: string | undefined;
}

export class SubmitNewTeamForApprovalInput
    implements ISubmitNewTeamForApprovalInput {
    teamId!: number | undefined;
    sysStatusId!: number | undefined;

    constructor(data?: ISubmitNewTeamForApprovalInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.teamId = data["teamId"];
            this.sysStatusId = data["sysStatusId"];
        }
    }

    static fromJS(data: any): SubmitNewTeamForApprovalInput {
        data = typeof data === "object" ? data : {};
        let result = new SubmitNewTeamForApprovalInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["teamId"] = this.teamId;
        data["sysStatusId"] = this.sysStatusId;
        return data;
    }
}

export interface ISubmitNewTeamForApprovalInput {
    teamId: number | undefined;
    sysStatusId: number | undefined;
}

export class PagedResultDtoOfApprovalUserLookupTableDto implements IPagedResultDtoOfApprovalUserLookupTableDto {
    totalCount!: number;
    items!: ApprovalUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApprovalUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export class ApprovalUserLookupTableDto implements IApprovalUserLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export class PagedResultDtoOfGetApprovalForViewDto
    implements IPagedResultDtoOfGetApprovalForViewDto {
    totalCount!: number;
    items!: GetApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetApprovalForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfGetApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfApprovalUserLookupTableDto {
    totalCount: number;
    items: ApprovalUserLookupTableDto[] | undefined;
}

export interface IPagedResultDtoOfGetApprovalForViewDto {
    totalCount: number;
    items: GetApprovalForViewDto[] | undefined;
}

export class GetApprovalForViewDto implements IGetApprovalForViewDto {
    approval!: ApprovalDto;
    sysRefTenantId!: string | undefined;
    teamName!: string | undefined;
    projectName!: string | undefined;
    accountName!: string | undefined;
    userName!: string | undefined;
    sysStatusName!: string | undefined;
    refCode!: string | undefined;

    constructor(data?: IGetApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.approval = data["approval"]
                ? ApprovalDto.fromJS(data["approval"])
                : <any>undefined;
            this.sysRefTenantId = data["sysRefTenantId"];
            this.teamName = data["teamName"];
            this.projectName = data["projectName"];
            this.accountName = data["accountName"];
            this.userName = data["userName"];
            this.sysStatusName = data["sysStatusName"];
            this.refCode = data["refCode"];
        }
    }

    static fromJS(data: any): GetApprovalForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new GetApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["approval"] = this.approval
            ? this.approval.toJSON()
            : <any>undefined;
        data["sysRefTenantId"] = this.sysRefTenantId;
        data["teamName"] = this.teamName;
        data["projectName"] = this.projectName;
        data["accountName"] = this.accountName;
        data["userName"] = this.userName;
        data["sysStatusName"] = this.sysStatusName;
        data["refCode"] = this.refCode;
        return data;
    }
}

export interface IGetApprovalForViewDto {
    approval: ApprovalDto;
    sysRefTenantId: string | undefined;
    teamName: string | undefined;
    projectName: string | undefined;
    accountName: string | undefined;
    userName: string | undefined;
    sysStatusName: string | undefined;
    refCode: string | undefined;
}

export class ApprovalDto implements IApprovalDto {
    rankNo!: number;
    amount!: number;
    sysRefId!: number | undefined;
    teamId!: number | undefined;
    projectId!: number | undefined;
    accountId!: number | undefined;
    userId!: number | undefined;
    sysStatusId!: number | undefined;
    id!: number;

    constructor(data?: IApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rankNo = data["rankNo"];
            this.amount = data["amount"];
            this.sysRefId = data["sysRefId"];
            this.teamId = data["teamId"];
            this.projectId = data["projectId"];
            this.accountId = data["accountId"];
            this.userId = data["userId"];
            this.sysStatusId = data["sysStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApprovalDto {
        data = typeof data === "object" ? data : {};
        let result = new ApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["rankNo"] = this.rankNo;
        data["amount"] = this.amount;
        data["sysRefId"] = this.sysRefId;
        data["teamId"] = this.teamId;
        data["projectId"] = this.projectId;
        data["accountId"] = this.accountId;
        data["userId"] = this.userId;
        data["sysStatusId"] = this.sysStatusId;
        data["id"] = this.id;
        return data;
    }

}

export interface IApprovalDto {
    rankNo: number;
    amount: number;
    sysRefId: number | undefined;
    teamId: number | undefined;
    projectId: number | undefined;
    accountId: number | undefined;
    userId: number | undefined;
    sysStatusId: number | undefined;
    id: number;
}

export class PagedResultDtoOfApprovalSysStatusLookupTableDto implements IPagedResultDtoOfApprovalSysStatusLookupTableDto {
    totalCount!: number;
    items!: ApprovalSysStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApprovalSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApprovalSysStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalSysStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApprovalSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export class ApprovalSysStatusLookupTableDto implements IApprovalSysStatusLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IApprovalSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ApprovalSysStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IPagedResultDtoOfApprovalSysStatusLookupTableDto {
    totalCount: number;
    items: ApprovalSysStatusLookupTableDto[] | undefined;
}

export interface IApprovalSysStatusLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class CreateOrEditApprovalDto implements ICreateOrEditApprovalDto {
    rankNo!: number;
    amount!: number;
    sysRefId!: number | undefined;
    teamId!: number | undefined;
    projectId!: number | undefined;
    accountId!: number | undefined;
    userId!: number | undefined;
    sysStatusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rankNo = data["rankNo"];
            this.amount = data["amount"];
            this.sysRefId = data["sysRefId"];
            this.teamId = data["teamId"];
            this.projectId = data["projectId"];
            this.accountId = data["accountId"];
            this.userId = data["userId"];
            this.sysStatusId = data["sysStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rankNo"] = this.rankNo;
        data["amount"] = this.amount;
        data["sysRefId"] = this.sysRefId;
        data["teamId"] = this.teamId;
        data["projectId"] = this.projectId;
        data["accountId"] = this.accountId;
        data["userId"] = this.userId;
        data["sysStatusId"] = this.sysStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditApprovalDto {
    rankNo: number;
    amount: number;
    sysRefId: number | undefined;
    teamId: number | undefined;
    projectId: number | undefined;
    accountId: number | undefined;
    userId: number | undefined;
    sysStatusId: number | undefined;
    id: number | undefined;
}

export class GetApprovalForEditOutput implements IGetApprovalForEditOutput {
    approval!: CreateOrEditApprovalDto;
    sysRefTenantId!: string | undefined;
    teamName!: string | undefined;
    projectName!: string | undefined;
    accountName!: string | undefined;
    userName!: string | undefined;
    sysStatusName!: string | undefined;

    constructor(data?: IGetApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.approval = data["approval"] ? CreateOrEditApprovalDto.fromJS(data["approval"]) : <any>undefined;
            this.sysRefTenantId = data["sysRefTenantId"];
            this.teamName = data["teamName"];
            this.projectName = data["projectName"];
            this.accountName = data["accountName"];
            this.userName = data["userName"];
            this.sysStatusName = data["sysStatusName"];
        }
    }

    static fromJS(data: any): GetApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approval"] = this.approval ? this.approval.toJSON() : <any>undefined;
        data["sysRefTenantId"] = this.sysRefTenantId;
        data["teamName"] = this.teamName;
        data["projectName"] = this.projectName;
        data["accountName"] = this.accountName;
        data["userName"] = this.userName;
        data["sysStatusName"] = this.sysStatusName;
        return data; 
    }
}

export interface IGetApprovalForEditOutput {
    approval: CreateOrEditApprovalDto;
    sysRefTenantId: string | undefined;
    teamName: string | undefined;
    projectName: string | undefined;
    accountName: string | undefined;
    userName: string | undefined;
    sysStatusName: string | undefined;
}

export class ApprovalSysRefLookupTableDto implements IApprovalSysRefLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IApprovalSysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ApprovalSysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalSysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IApprovalSysRefLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfApprovalSysRefLookupTableDto implements IPagedResultDtoOfApprovalSysRefLookupTableDto {
    totalCount!: number;
    items!: ApprovalSysRefLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApprovalSysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApprovalSysRefLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalSysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApprovalSysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfApprovalSysRefLookupTableDto {
    totalCount: number;
    items: ApprovalSysRefLookupTableDto[] | undefined;
}

export class ApprovalTeamLookupTableDto implements IApprovalTeamLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IApprovalTeamLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ApprovalTeamLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalTeamLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IApprovalTeamLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfApprovalTeamLookupTableDto implements IPagedResultDtoOfApprovalTeamLookupTableDto {
    totalCount!: number;
    items!: ApprovalTeamLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApprovalTeamLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApprovalTeamLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalTeamLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApprovalTeamLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfApprovalTeamLookupTableDto {
    totalCount: number;
    items: ApprovalTeamLookupTableDto[] | undefined;
}

export class ApprovalProjectLookupTableDto implements IApprovalProjectLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IApprovalProjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ApprovalProjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalProjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IApprovalProjectLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfApprovalProjectLookupTableDto implements IPagedResultDtoOfApprovalProjectLookupTableDto {
    totalCount!: number;
    items!: ApprovalProjectLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApprovalProjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApprovalProjectLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalProjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApprovalProjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfApprovalProjectLookupTableDto {
    totalCount: number;
    items: ApprovalProjectLookupTableDto[] | undefined;
}

export interface IPagedResultDtoOfApprovalAccountLookupTableDto {
    totalCount: number;
    items: ApprovalAccountLookupTableDto[] | undefined;
}

export interface IApprovalUserLookupTableDto {
    id: number;
    displayName: string | undefined;
}

//#endregion

//#region ApprovalAccount
export class ApprovalAccountLookupTableDto implements IApprovalAccountLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IApprovalAccountLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ApprovalAccountLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalAccountLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IApprovalAccountLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfApprovalAccountLookupTableDto implements IPagedResultDtoOfApprovalAccountLookupTableDto {
    totalCount!: number;
    items!: ApprovalAccountLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApprovalAccountLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApprovalAccountLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalAccountLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApprovalAccountLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfApprovalAccountLookupTableDto {
    totalCount: number;
    items: ApprovalAccountLookupTableDto[] | undefined;
}

//#endregion ApprovalAccount

//#region ApprovalRequest

@Injectable()
export class ApprovalRequestsCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReferenceIdFilter (optional) 
     * @param minReferenceIdFilter (optional) 
     * @param maxOrderNoFilter (optional) 
     * @param minOrderNoFilter (optional) 
     * @param maxRankNoFilter (optional) 
     * @param minRankNoFilter (optional) 
     * @param maxAmountFilter (optional) 
     * @param minAmountFilter (optional) 
     * @param remarkFilter (optional) 
     * @param sysRefTenantIdFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxReferenceIdFilter: number | undefined, minReferenceIdFilter: number | undefined, maxOrderNoFilter: number | undefined, minOrderNoFilter: number | undefined, maxRankNoFilter: number | undefined, minRankNoFilter: number | undefined, maxAmountFilter: number | undefined, minAmountFilter: number | undefined, remarkFilter: string | undefined, sysRefTenantIdFilter: string | undefined, sysStatusNameFilter: string | undefined, userNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetApprovalRequestForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequests/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReferenceIdFilter === null)
            throw new Error("The parameter 'maxReferenceIdFilter' cannot be null.");
        else if (maxReferenceIdFilter !== undefined)
            url_ += "MaxReferenceIdFilter=" + encodeURIComponent("" + maxReferenceIdFilter) + "&"; 
        if (minReferenceIdFilter === null)
            throw new Error("The parameter 'minReferenceIdFilter' cannot be null.");
        else if (minReferenceIdFilter !== undefined)
            url_ += "MinReferenceIdFilter=" + encodeURIComponent("" + minReferenceIdFilter) + "&"; 
        if (maxOrderNoFilter === null)
            throw new Error("The parameter 'maxOrderNoFilter' cannot be null.");
        else if (maxOrderNoFilter !== undefined)
            url_ += "MaxOrderNoFilter=" + encodeURIComponent("" + maxOrderNoFilter) + "&"; 
        if (minOrderNoFilter === null)
            throw new Error("The parameter 'minOrderNoFilter' cannot be null.");
        else if (minOrderNoFilter !== undefined)
            url_ += "MinOrderNoFilter=" + encodeURIComponent("" + minOrderNoFilter) + "&"; 
        if (maxRankNoFilter === null)
            throw new Error("The parameter 'maxRankNoFilter' cannot be null.");
        else if (maxRankNoFilter !== undefined)
            url_ += "MaxRankNoFilter=" + encodeURIComponent("" + maxRankNoFilter) + "&"; 
        if (minRankNoFilter === null)
            throw new Error("The parameter 'minRankNoFilter' cannot be null.");
        else if (minRankNoFilter !== undefined)
            url_ += "MinRankNoFilter=" + encodeURIComponent("" + minRankNoFilter) + "&"; 
        if (maxAmountFilter === null)
            throw new Error("The parameter 'maxAmountFilter' cannot be null.");
        else if (maxAmountFilter !== undefined)
            url_ += "MaxAmountFilter=" + encodeURIComponent("" + maxAmountFilter) + "&"; 
        if (minAmountFilter === null)
            throw new Error("The parameter 'minAmountFilter' cannot be null.");
        else if (minAmountFilter !== undefined)
            url_ += "MinAmountFilter=" + encodeURIComponent("" + minAmountFilter) + "&"; 
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (sysRefTenantIdFilter === null)
            throw new Error("The parameter 'sysRefTenantIdFilter' cannot be null.");
        else if (sysRefTenantIdFilter !== undefined)
            url_ += "SysRefTenantIdFilter=" + encodeURIComponent("" + sysRefTenantIdFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetApprovalRequestForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetApprovalRequestForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetApprovalRequestForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetApprovalRequestForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetApprovalRequestForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getApprovalRequestForView(id: number | undefined): Observable<GetApprovalRequestForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequests/GetApprovalRequestForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovalRequestForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovalRequestForView(<any>response_);
                } catch (e) {
                    return <Observable<GetApprovalRequestForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApprovalRequestForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApprovalRequestForView(response: HttpResponseBase): Observable<GetApprovalRequestForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetApprovalRequestForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApprovalRequestForViewDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxReferenceIdFilter (optional) 
     * @param minReferenceIdFilter (optional) 
     * @param maxOrderNoFilter (optional) 
     * @param minOrderNoFilter (optional) 
     * @param maxUserIdFilter (optional) 
     * @param minUserIdFilter (optional) 
     * @param maxRankNoFilter (optional) 
     * @param minRankNoFilter (optional) 
     * @param maxAmountFilter (optional) 
     * @param minAmountFilter (optional) 
     * @param remarkFilter (optional) 
     * @param sysRefTenantIdFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getApprovalRequest(referenceId: number | undefined, sysRefId: number | undefined, sysStatusId: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetApprovalRequestForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonQuery/GetApprovalRequest?";
        if (referenceId === null)
            throw new Error("The parameter 'referenceId' cannot be null.");
        else if (referenceId !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + referenceId) + "&"; 
        if (sysRefId === null)
            throw new Error("The parameter 'sysRefId' cannot be null.");
        else if (sysRefId !== undefined)
            url_ += "MaxReferenceIdFilter=" + encodeURIComponent("" + sysRefId) + "&"; 
        if (sysStatusId === null)
            throw new Error("The parameter 'sysStatusId' cannot be null.");
        else if (sysStatusId !== undefined)
            url_ += "MinReferenceIdFilter=" + encodeURIComponent("" + sysStatusId) + "&";         
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovalRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovalRequest(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetApprovalRequestForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetApprovalRequestForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApprovalRequest(response: HttpResponseBase): Observable<PagedResultDtoOfGetApprovalRequestForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetApprovalRequestForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetApprovalRequestForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getApprovalRequestForEdit(id: number | undefined): Observable<GetApprovalRequestForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequests/GetApprovalRequestForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovalRequestForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovalRequestForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetApprovalRequestForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApprovalRequestForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetApprovalRequestForEdit(response: HttpResponseBase): Observable<GetApprovalRequestForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetApprovalRequestForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApprovalRequestForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditApprovalRequestDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequests/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequests/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxReferenceIdFilter (optional) 
     * @param minReferenceIdFilter (optional) 
     * @param maxOrderNoFilter (optional) 
     * @param minOrderNoFilter (optional) 
     * @param maxRankNoFilter (optional) 
     * @param minRankNoFilter (optional) 
     * @param maxAmountFilter (optional) 
     * @param minAmountFilter (optional) 
     * @param remarkFilter (optional) 
     * @param sysRefTenantIdFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @return Success
     */
    getApprovalRequestsToExcel(filter: string | undefined, maxReferenceIdFilter: number | undefined, minReferenceIdFilter: number | undefined, maxOrderNoFilter: number | undefined, minOrderNoFilter: number | undefined, maxRankNoFilter: number | undefined, minRankNoFilter: number | undefined, maxAmountFilter: number | undefined, minAmountFilter: number | undefined, remarkFilter: string | undefined, sysRefTenantIdFilter: string | undefined, sysStatusNameFilter: string | undefined, userNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequests/GetApprovalRequestsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReferenceIdFilter === null)
            throw new Error("The parameter 'maxReferenceIdFilter' cannot be null.");
        else if (maxReferenceIdFilter !== undefined)
            url_ += "MaxReferenceIdFilter=" + encodeURIComponent("" + maxReferenceIdFilter) + "&"; 
        if (minReferenceIdFilter === null)
            throw new Error("The parameter 'minReferenceIdFilter' cannot be null.");
        else if (minReferenceIdFilter !== undefined)
            url_ += "MinReferenceIdFilter=" + encodeURIComponent("" + minReferenceIdFilter) + "&"; 
        if (maxOrderNoFilter === null)
            throw new Error("The parameter 'maxOrderNoFilter' cannot be null.");
        else if (maxOrderNoFilter !== undefined)
            url_ += "MaxOrderNoFilter=" + encodeURIComponent("" + maxOrderNoFilter) + "&"; 
        if (minOrderNoFilter === null)
            throw new Error("The parameter 'minOrderNoFilter' cannot be null.");
        else if (minOrderNoFilter !== undefined)
            url_ += "MinOrderNoFilter=" + encodeURIComponent("" + minOrderNoFilter) + "&"; 
        if (maxRankNoFilter === null)
            throw new Error("The parameter 'maxRankNoFilter' cannot be null.");
        else if (maxRankNoFilter !== undefined)
            url_ += "MaxRankNoFilter=" + encodeURIComponent("" + maxRankNoFilter) + "&"; 
        if (minRankNoFilter === null)
            throw new Error("The parameter 'minRankNoFilter' cannot be null.");
        else if (minRankNoFilter !== undefined)
            url_ += "MinRankNoFilter=" + encodeURIComponent("" + minRankNoFilter) + "&"; 
        if (maxAmountFilter === null)
            throw new Error("The parameter 'maxAmountFilter' cannot be null.");
        else if (maxAmountFilter !== undefined)
            url_ += "MaxAmountFilter=" + encodeURIComponent("" + maxAmountFilter) + "&"; 
        if (minAmountFilter === null)
            throw new Error("The parameter 'minAmountFilter' cannot be null.");
        else if (minAmountFilter !== undefined)
            url_ += "MinAmountFilter=" + encodeURIComponent("" + minAmountFilter) + "&"; 
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (sysRefTenantIdFilter === null)
            throw new Error("The parameter 'sysRefTenantIdFilter' cannot be null.");
        else if (sysRefTenantIdFilter !== undefined)
            url_ += "SysRefTenantIdFilter=" + encodeURIComponent("" + sysRefTenantIdFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovalRequestsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovalRequestsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApprovalRequestsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysRefForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfApprovalRequestSysRefLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequests/GetAllSysRefForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysRefForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysRefForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApprovalRequestSysRefLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApprovalRequestSysRefLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysRefForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfApprovalRequestSysRefLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApprovalRequestSysRefLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApprovalRequestSysRefLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysStatusForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfApprovalRequestSysStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequests/GetAllSysStatusForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApprovalRequestSysStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApprovalRequestSysStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfApprovalRequestSysStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApprovalRequestSysStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApprovalRequestSysStatusLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfApprovalRequestUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequests/GetAllUserForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApprovalRequestUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApprovalRequestUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfApprovalRequestUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApprovalRequestUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApprovalRequestUserLookupTableDto>(<any>null);
    }
}
export class PagedResultDtoOfGetApprovalRequestForViewDto implements IPagedResultDtoOfGetApprovalRequestForViewDto {
    totalCount!: number;
    items!: GetApprovalRequestForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetApprovalRequestForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetApprovalRequestForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetApprovalRequestForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetApprovalRequestForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetApprovalRequestForViewDto {
    totalCount: number;
    items: GetApprovalRequestForViewDto[] | undefined;
}

export class GetApprovalRequestForViewDto implements IGetApprovalRequestForViewDto {
    approvalRequest!: ApprovalRequestDto;
    sysRefTenantId!: string | undefined;
    sysStatusName!: string | undefined;
    fullName!: string | undefined;
    emailAddress!: string | undefined;
    profilePicture!: string | undefined;
    userName!: string | undefined;
    canApprove!:boolean | undefined;

    constructor(data?: IGetApprovalRequestForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.approvalRequest = data["approvalRequest"] ? ApprovalRequestDto.fromJS(data["approvalRequest"]) : <any>undefined;
            this.sysRefTenantId = data["sysRefTenantId"];
            this.sysStatusName = data["sysStatusName"];
            this.fullName = data["fullName"];
            this.emailAddress = data["emailAddress"];
            this.profilePicture = data["profilePicture"];
            this.userName = data["userName"];
            this.canApprove = data["canApprove"];
        }
    }

    static fromJS(data: any): GetApprovalRequestForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetApprovalRequestForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalRequest"] = this.approvalRequest ? this.approvalRequest.toJSON() : <any>undefined;
        data["sysRefTenantId"] = this.sysRefTenantId;
        data["sysStatusName"] = this.sysStatusName;
        data["fullName"] = this.fullName ;
        data["emailAddress"] = this.emailAddress;
        data["profilePicture"] = this.profilePicture;
        data["userName"] = this.userName;
        data["canApprove"] = this.canApprove;
        return data; 
    }
}

export interface IGetApprovalRequestForViewDto {
    approvalRequest: ApprovalRequestDto;
    sysRefTenantId: string | undefined;
    sysStatusName: string | undefined;
    fullName: string | undefined;
    emailAddress: string | undefined;
    profilePicture: string | undefined;
    userName: string | undefined;
    canApprove:boolean | undefined;

}


export class ApprovalRequestDto implements IApprovalRequestDto {
    referenceId!: number;
    orderNo!: number;
    userId!: number;
    rankNo!: number;
    amount!: number;
    remark!: string | undefined;
    sysRefId!: number | undefined;
    sysStatusId!: number | undefined;
    sysStatusName!: string | undefined;
    id!: number;

    constructor(data?: IApprovalRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.referenceId = data["referenceId"];
            this.orderNo = data["orderNo"];
            this.userId = data["userId"];
            this.rankNo = data["rankNo"];
            this.amount = data["amount"];
            this.remark = data["remark"];
            this.sysRefId = data["sysRefId"];
            this.sysStatusId = data["sysStatusId"];
            this.sysStatusName = data["sysStatusName"];
            this.id = data["id"];
          
        }
    }

    static fromJS(data: any): ApprovalRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceId"] = this.referenceId;
        data["orderNo"] = this.orderNo;
        data["userId"] = this.userId;
        data["rankNo"] = this.rankNo;
        data["amount"] = this.amount;
        data["remark"] = this.remark;
        data["sysRefId"] = this.sysRefId;
        data["sysStatusId"] = this.sysStatusId;
        data["sysStatusName"] = this.sysStatusName;
        data["id"] = this.id;    
        return data; 
    }
}

export interface IApprovalRequestDto {
    referenceId: number;
    orderNo: number;
    userId: number;
    rankNo: number;
    amount: number;
    remark: string | undefined;
    sysRefId: number | undefined;
    sysStatusId: number | undefined;
    sysStatusName: string | undefined;
    id: number;  
}


export class CreateOrEditApprovalRequestDto implements ICreateOrEditApprovalRequestDto {
    referenceId!: number;
    orderNo!: number;
    rankNo!: number;
    amount!: number;
    remark!: string | undefined;
    sysRefId!: number | undefined;
    sysStatusId!: number | undefined;
    userId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditApprovalRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.referenceId = data["referenceId"];
            this.orderNo = data["orderNo"];
            this.rankNo = data["rankNo"];
            this.amount = data["amount"];
            this.remark = data["remark"];
            this.sysRefId = data["sysRefId"];
            this.sysStatusId = data["sysStatusId"];
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditApprovalRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditApprovalRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceId"] = this.referenceId;
        data["orderNo"] = this.orderNo;
        data["rankNo"] = this.rankNo;
        data["amount"] = this.amount;
        data["remark"] = this.remark;
        data["sysRefId"] = this.sysRefId;
        data["sysStatusId"] = this.sysStatusId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditApprovalRequestDto {
    referenceId: number;
    orderNo: number;
    rankNo: number;
    amount: number;
    remark: string | undefined;
    sysRefId: number | undefined;
    sysStatusId: number | undefined;
    userId: number | undefined;
    id: number | undefined;
}

export class GetApprovalRequestForEditOutput implements IGetApprovalRequestForEditOutput {
    approvalRequest!: CreateOrEditApprovalRequestDto;
    sysRefTenantId!: string | undefined;
    sysStatusName!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetApprovalRequestForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.approvalRequest = data["approvalRequest"] ? CreateOrEditApprovalRequestDto.fromJS(data["approvalRequest"]) : <any>undefined;
            this.sysRefTenantId = data["sysRefTenantId"];
            this.sysStatusName = data["sysStatusName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetApprovalRequestForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetApprovalRequestForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalRequest"] = this.approvalRequest ? this.approvalRequest.toJSON() : <any>undefined;
        data["sysRefTenantId"] = this.sysRefTenantId;
        data["sysStatusName"] = this.sysStatusName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetApprovalRequestForEditOutput {
    approvalRequest: CreateOrEditApprovalRequestDto;
    sysRefTenantId: string | undefined;
    sysStatusName: string | undefined;
    userName: string | undefined;
}

export class ApprovalRequestSysRefLookupTableDto implements IApprovalRequestSysRefLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IApprovalRequestSysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ApprovalRequestSysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalRequestSysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IApprovalRequestSysRefLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfApprovalRequestSysRefLookupTableDto implements IPagedResultDtoOfApprovalRequestSysRefLookupTableDto {
    totalCount!: number;
    items!: ApprovalRequestSysRefLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApprovalRequestSysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApprovalRequestSysRefLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalRequestSysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApprovalRequestSysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfApprovalRequestSysRefLookupTableDto {
    totalCount: number;
    items: ApprovalRequestSysRefLookupTableDto[] | undefined;
}

export class ApprovalRequestSysStatusLookupTableDto implements IApprovalRequestSysStatusLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IApprovalRequestSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ApprovalRequestSysStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalRequestSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IApprovalRequestSysStatusLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfApprovalRequestSysStatusLookupTableDto implements IPagedResultDtoOfApprovalRequestSysStatusLookupTableDto {
    totalCount!: number;
    items!: ApprovalRequestSysStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApprovalRequestSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApprovalRequestSysStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalRequestSysStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApprovalRequestSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfApprovalRequestSysStatusLookupTableDto {
    totalCount: number;
    items: ApprovalRequestSysStatusLookupTableDto[] | undefined;
}

export class ApprovalRequestUserLookupTableDto implements IApprovalRequestUserLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IApprovalRequestUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ApprovalRequestUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalRequestUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IApprovalRequestUserLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfApprovalRequestUserLookupTableDto implements IPagedResultDtoOfApprovalRequestUserLookupTableDto {
    totalCount!: number;
    items!: ApprovalRequestUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApprovalRequestUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApprovalRequestUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalRequestUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApprovalRequestUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfApprovalRequestUserLookupTableDto {
    totalCount: number;
    items: ApprovalRequestUserLookupTableDto[] | undefined;
}
//#endregion Approval Request 

//#region CommonLookUpService

@Injectable()
export class CommonQueryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

   /**
     * @param permissions (optional) 
     * @return Success
     */
    getRoles(permissions: string[] | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonQuery/GetRoles?";
        if (permissions === null)
            throw new Error("The parameter 'permissions' cannot be null.");
        else if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    getIsUserAdmin( userId: number | undefined, userName: string | undefined): Observable<RequestOutput> {
        console.log("this.baseUrl",this.baseUrl)
        let url_ =this.baseUrl + "/api/services/app/CommonQuery/GetIsUserAdmin?";

        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        console.log("url",url_)

       let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIsUserAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIsUserAdmin(<any>response_);
                } catch (e) {
                    return <Observable<RequestOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIsUserAdmin(response: HttpResponseBase): Observable<RequestOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestOutput>(<any>null);
    }

    
}


export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}


export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    creationTime!: moment.Moment;
    id!: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class UserInput
    implements IUserInput {
    userId!: number | undefined;
    userName!: string | undefined;

    constructor(data?: ISubmitNewTeamForApprovalInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): SubmitNewTeamForApprovalInput {
        data = typeof data === "object" ? data : {};
        let result = new SubmitNewTeamForApprovalInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IUserInput {
    userId: number | undefined;
    userName: string | undefined;
}

//#endregion 

//#region Category

@Injectable()
export class CategoriesCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, isApprovedFilter: number | undefined, isActiveFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Categories/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (isApprovedFilter === null)
            throw new Error("The parameter 'isApprovedFilter' cannot be null.");
        else if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCategoryForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCategoryForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCategoryForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCategoryForViewDto>(<any>null);
    }

    /**
     * @return Success
     */
    getCategoriesNameValue(): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/Categories/GetCategoriesNameValue";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoriesNameValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoriesNameValue(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoriesNameValue(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCategoryForView(id: number | undefined): Observable<GetCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Categories/GetCategoryForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCategoryForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCategoryForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoryForView(response: HttpResponseBase): Observable<GetCategoryForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCategoryForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCategoryForEdit(id: number | undefined): Observable<GetCategoryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Categories/GetCategoryForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCategoryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCategoryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoryForEdit(response: HttpResponseBase): Observable<GetCategoryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCategoryForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCategoryForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Categories/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Categories/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param isActiveFilter (optional) 
     * @return Success
     */
    getCategoriesToExcel(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, isApprovedFilter: number | undefined, isActiveFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Categories/GetCategoriesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (isApprovedFilter === null)
            throw new Error("The parameter 'isApprovedFilter' cannot be null.");
        else if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoriesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoriesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoriesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}


export interface IEntityDtoOfString {
    id: string | undefined;
}

export class CategoryDto implements ICategoryDto {
    name!: string | undefined;
    description!: string | undefined;
    isApproved!: boolean;
    isActive!: boolean;
    id!: number;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.isApproved = data["isApproved"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["isApproved"] = this.isApproved;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICategoryDto {
    name: string | undefined;
    description: string | undefined;
    isApproved: boolean;
    isActive: boolean;
    id: number;
}

export class GetCategoryForViewDto implements IGetCategoryForViewDto {
    category!: CategoryDto;

    constructor(data?: IGetCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"] ? CategoryDto.fromJS(data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCategoryForViewDto {
    category: CategoryDto;
}

export class PagedResultDtoOfGetCategoryForViewDto implements IPagedResultDtoOfGetCategoryForViewDto {
    totalCount!: number;
    items!: GetCategoryForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCategoryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCategoryForViewDto {
    totalCount: number;
    items: GetCategoryForViewDto[] | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class CreateOrEditCategoryDto implements ICreateOrEditCategoryDto {
    name!: string | undefined;
    description!: string | undefined;
    isApproved!: boolean;
    isActive!: boolean;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.isApproved = data["isApproved"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["isApproved"] = this.isApproved;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCategoryDto {
    name: string | undefined;
    description: string | undefined;
    isApproved: boolean;
    isActive: boolean;
    id: number | undefined;
}

export class GetCategoryForEditOutput implements IGetCategoryForEditOutput {
    category!: CreateOrEditCategoryDto;

    constructor(data?: IGetCategoryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"] ? CreateOrEditCategoryDto.fromJS(data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCategoryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCategoryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCategoryForEditOutput {
    category: CreateOrEditCategoryDto;
}
//#endregion Category

//#region Document
@Injectable()
export class DocumentsCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param urlFilter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sysRefTenantIdFilter (optional) 
     * @param productNameFilter (optional) 
     * @param serviceNameFilter (optional) 
     * @param productIdFilter (optional) 
     * @param serviceIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, urlFilter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, sysRefTenantIdFilter: string | undefined, productNameFilter: string | undefined, serviceNameFilter: string | undefined, productIdFilter: number | undefined, serviceIdFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDocumentForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Documents/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sysRefTenantIdFilter === null)
            throw new Error("The parameter 'sysRefTenantIdFilter' cannot be null.");
        else if (sysRefTenantIdFilter !== undefined)
            url_ += "SysRefTenantIdFilter=" + encodeURIComponent("" + sysRefTenantIdFilter) + "&"; 
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&"; 
        if (serviceNameFilter === null)
            throw new Error("The parameter 'serviceNameFilter' cannot be null.");
        else if (serviceNameFilter !== undefined)
            url_ += "ServiceNameFilter=" + encodeURIComponent("" + serviceNameFilter) + "&"; 
        if (productIdFilter === null)
            throw new Error("The parameter 'productIdFilter' cannot be null.");
        else if (productIdFilter !== undefined)
            url_ += "ProductIdFilter=" + encodeURIComponent("" + productIdFilter) + "&"; 
        if (serviceIdFilter === null)
            throw new Error("The parameter 'serviceIdFilter' cannot be null.");
        else if (serviceIdFilter !== undefined)
            url_ += "ServiceIdFilter=" + encodeURIComponent("" + serviceIdFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDocumentForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDocumentForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDocumentForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetDocumentForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDocumentForViewDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param urlFilter (optional)
     * @param nameFilter (optional)
     * @param descriptionFilter (optional)
     * @param sysRefTenantIdFilter (optional)
     * @param productNameFilter (optional)
     * @param serviceNameFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getDocuments(
        filter: string | undefined,
        urlFilter: string | undefined,
        nameFilter: string | undefined,
        descriptionFilter: string | undefined,
        sysRefTenantIdFilter: string | undefined,
        productNameFilter: string | undefined,
        serviceNameFilter: string | undefined,
        productIdFilter: number | undefined,
        serviceIdFilter: number | undefined,
        sorting: string | undefined,
        skipCount: number | undefined,
        maxResultCount: number | undefined
    ): Observable<PagedResultDtoOfGetDocumentForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/documents/GetDocuments?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error(
                "The parameter 'descriptionFilter' cannot be null."
            );
        else if (descriptionFilter !== undefined)
            url_ +=
                "DescriptionFilter=" +
                encodeURIComponent("" + descriptionFilter) +
                "&";
        if (sysRefTenantIdFilter === null)
            throw new Error(
                "The parameter 'sysRefTenantIdFilter' cannot be null."
            );
        else if (sysRefTenantIdFilter !== undefined)
            url_ +=
                "SysRefTenantIdFilter=" +
                encodeURIComponent("" + sysRefTenantIdFilter) +
                "&";
        if (productNameFilter === null)
            throw new Error(
                "The parameter 'productNameFilter' cannot be null."
            );
        else if (productNameFilter !== undefined)
            url_ +=
                "ProductNameFilter=" +
                encodeURIComponent("" + productNameFilter) +
                "&";
        if (serviceNameFilter === null)
            throw new Error(
                "The parameter 'serviceNameFilter' cannot be null."
            );
        else if (serviceNameFilter !== undefined)
            url_ +=
                "ServiceNameFilter=" +
                encodeURIComponent("" + serviceNameFilter) +
                "&";
        if (productIdFilter === null)
            throw new Error("The parameter 'productIdFilter' cannot be null.");
        else if (productIdFilter !== undefined)
            url_ +=
                "productIdFilter=" +
                encodeURIComponent("" + productIdFilter) +
                "&";
        if (serviceIdFilter === null)
            throw new Error("The parameter 'serviceIdFilter' cannot be null.");
        else if (serviceIdFilter !== undefined)
            url_ +=
                "serviceIdFilter=" +
                encodeURIComponent("" + serviceIdFilter) +
                "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };
        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetDocuments(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetDocuments(<any>response_);
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfGetDocumentForViewDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<PagedResultDtoOfGetDocumentForViewDto>
                        >(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetDocuments(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfGetDocumentForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfGetDocumentForViewDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfGetDocumentForViewDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    uploadDocuments(body: UploadDocumentsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/documents/UpdateDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json"
            })
        };

        return this.http
            .request("put", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUploadDocuments(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUploadDocuments(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else
                        return <Observable<void>>(
                            (<any>_observableThrow(response_))
                        );
                })
            );
    }

    protected processUploadDocuments(
        response: HttpResponseBase
    ): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentForView(id: number | undefined): Observable<GetDocumentForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Documents/GetDocumentForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentForView(<any>response_);
                } catch (e) {
                    return <Observable<GetDocumentForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDocumentForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentForView(response: HttpResponseBase): Observable<GetDocumentForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDocumentForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentForEdit(id: number | undefined): Observable<GetDocumentForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Documents/GetDocumentForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDocumentForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDocumentForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentForEdit(response: HttpResponseBase): Observable<GetDocumentForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDocumentForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDocuments(body: UpdateDocumentsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Documents/UpdateDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocuments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDocuments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDocumentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Documents/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Documents/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param urlFilter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sysRefTenantIdFilter (optional) 
     * @param productNameFilter (optional) 
     * @param serviceNameFilter (optional) 
     * @return Success
     */
    getDocumentsToExcel(filter: string | undefined, urlFilter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, sysRefTenantIdFilter: string | undefined, productNameFilter: string | undefined, serviceNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Documents/GetDocumentsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sysRefTenantIdFilter === null)
            throw new Error("The parameter 'sysRefTenantIdFilter' cannot be null.");
        else if (sysRefTenantIdFilter !== undefined)
            url_ += "SysRefTenantIdFilter=" + encodeURIComponent("" + sysRefTenantIdFilter) + "&"; 
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&"; 
        if (serviceNameFilter === null)
            throw new Error("The parameter 'serviceNameFilter' cannot be null.");
        else if (serviceNameFilter !== undefined)
            url_ += "ServiceNameFilter=" + encodeURIComponent("" + serviceNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysRefForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfDocumentSysRefLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Documents/GetAllSysRefForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysRefForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysRefForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDocumentSysRefLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDocumentSysRefLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysRefForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfDocumentSysRefLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDocumentSysRefLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDocumentSysRefLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProductForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfDocumentProductLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Documents/GetAllProductForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDocumentProductLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDocumentProductLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfDocumentProductLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDocumentProductLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDocumentProductLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllServiceForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfDocumentServiceLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Documents/GetAllServiceForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllServiceForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllServiceForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDocumentServiceLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDocumentServiceLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllServiceForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfDocumentServiceLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDocumentServiceLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDocumentServiceLookupTableDto>(<any>null);
    }
}

export class PagedResultDtoOfGetDocumentForViewDto
    implements IPagedResultDtoOfGetDocumentForViewDto {
    totalCount!: number;
    items!: GetDocumentForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDocumentForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetDocumentForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDocumentForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfGetDocumentForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class UploadDocumentsInput implements IUploadDocumentsInput {
    fileToken!: string | undefined;
    x!: number;
    y!: number;
    width!: number;
    height!: number;
    productId: number;
    serviceId: number;
    Name: string | undefined;
    fileExt: string | undefined;
    description: string | undefined;

    constructor(data?: IUploadDocumentsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
            this.productId = data["productId"];
            this.serviceId = data["serviceId"];
            this.Name = data["Name"];
            this.fileExt = data["fileExt"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): UploadDocumentsInput {
        data = typeof data === "object" ? data : {};
        let result = new UploadDocumentsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        data["productId"] = this.productId;
        data["serviceId"] = this.serviceId;
        data["Name"] = this.Name;
        data["fileExt"] = this.fileExt;
        data["description"] = this.description;
        return data;
    }
}

export interface IUploadDocumentsInput {
    fileToken: string | undefined;
    x: number;
    y: number;
    width: number;
    height: number;
    productId: number;
    serviceId: number;
    Name: string | undefined;
    fileExt: string | undefined;
    description: string | undefined;
}

export interface IPagedResultDtoOfGetDocumentForViewDto {
    totalCount: number;
    items: GetDocumentForViewDto[] | undefined;
}

export class GetDocumentForViewDto implements IGetDocumentForViewDto {
    document!: DocumentDto;
    sysRefTenantId!: string | undefined;
    productName!: string | undefined;
    serviceName!: string | undefined;

    constructor(data?: IGetDocumentForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.document = data["document"]
                ? DocumentDto.fromJS(data["document"])
                : <any>undefined;
            this.sysRefTenantId = data["sysRefTenantId"];
            this.productName = data["productName"];
            this.serviceName = data["serviceName"];
        }
    }

    static fromJS(data: any): GetDocumentForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new GetDocumentForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["document"] = this.document
            ? this.document.toJSON()
            : <any>undefined;
        data["sysRefTenantId"] = this.sysRefTenantId;
        data["productName"] = this.productName;
        data["serviceName"] = this.serviceName;
        return data;
    }
}

export class DocumentDto implements IDocumentDto {
    url!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    sysRefId!: number | undefined;
    productId!: number | undefined;
    serviceId!: number | undefined;
    id!: number;
    imageBase64String: string | undefined;

    constructor(data?: IDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.name = data["name"];
            this.description = data["description"];
            this.sysRefId = data["sysRefId"];
            this.productId = data["productId"];
            this.serviceId = data["serviceId"];
            this.id = data["id"];
            this.imageBase64String = data["imageBase64String"];
        }
    }

    static fromJS(data: any): DocumentDto {
        data = typeof data === "object" ? data : {};
        let result = new DocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["url"] = this.url;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sysRefId"] = this.sysRefId;
        data["productId"] = this.productId;
        data["serviceId"] = this.serviceId;
        data["id"] = this.id;
        data["imageBase64String"] = this.imageBase64String;

        return data;
    }
}

export interface IGetDocumentForViewDto {
    document: DocumentDto;
    sysRefTenantId: string | undefined;
    productName: string | undefined;
    serviceName: string | undefined;
}

export interface IDocumentDto {
    url: string | undefined;
    name: string | undefined;
    description: string | undefined;
    sysRefId: number | undefined;
    productId: number | undefined;
    serviceId: number | undefined;
    id: number;
    imageBase64String: string | undefined;
}

export interface IDocumentDto {
    url: string | undefined;
    name: string | undefined;
    description: string | undefined;
    sysRefId: number | undefined;
    productId: number | undefined;
    serviceId: number | undefined;
    imageBase64String: string | undefined;
    id: number;
}

export interface IGetDocumentForViewDto {
    document: DocumentDto;
    sysRefTenantId: string | undefined;
    productName: string | undefined;
    serviceName: string | undefined;
}

export class CreateOrEditDocumentDto implements ICreateOrEditDocumentDto {
    url!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    sysRefId!: number | undefined;
    productId!: number | undefined;
    serviceId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.name = data["name"];
            this.description = data["description"];
            this.sysRefId = data["sysRefId"];
            this.productId = data["productId"];
            this.serviceId = data["serviceId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sysRefId"] = this.sysRefId;
        data["productId"] = this.productId;
        data["serviceId"] = this.serviceId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditDocumentDto {
    url: string | undefined;
    name: string | undefined;
    description: string | undefined;
    sysRefId: number | undefined;
    productId: number | undefined;
    serviceId: number | undefined;
    id: number | undefined;
}

export class GetDocumentForEditOutput implements IGetDocumentForEditOutput {
    document!: CreateOrEditDocumentDto;
    sysRefTenantId!: string | undefined;
    productName!: string | undefined;
    serviceName!: string | undefined;

    constructor(data?: IGetDocumentForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.document = data["document"] ? CreateOrEditDocumentDto.fromJS(data["document"]) : <any>undefined;
            this.sysRefTenantId = data["sysRefTenantId"];
            this.productName = data["productName"];
            this.serviceName = data["serviceName"];
        }
    }

    static fromJS(data: any): GetDocumentForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["sysRefTenantId"] = this.sysRefTenantId;
        data["productName"] = this.productName;
        data["serviceName"] = this.serviceName;
        return data; 
    }
}

export interface IGetDocumentForEditOutput {
    document: CreateOrEditDocumentDto;
    sysRefTenantId: string | undefined;
    productName: string | undefined;
    serviceName: string | undefined;
}

export class UpdateDocumentsInput implements IUpdateDocumentsInput {
    fileToken!: string | undefined;
    x!: number;
    y!: number;
    productId!: number;
    serviceId!: number;
    name!: string | undefined;
    description!: string | undefined;
    fileExt!: string | undefined;
    sysRefId!: number;
    bytes!: string | undefined;

    constructor(data?: IUpdateDocumentsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.productId = data["productId"];
            this.serviceId = data["serviceId"];
            this.name = data["name"];
            this.description = data["description"];
            this.fileExt = data["fileExt"];
            this.sysRefId = data["sysRefId"];
            this.bytes = data["bytes"];
        }
    }

    static fromJS(data: any): UpdateDocumentsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["productId"] = this.productId;
        data["serviceId"] = this.serviceId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["fileExt"] = this.fileExt;
        data["sysRefId"] = this.sysRefId;
        data["bytes"] = this.bytes;
        return data; 
    }
}

export interface IUpdateDocumentsInput {
    fileToken: string | undefined;
    x: number;
    y: number;
    productId: number;
    serviceId: number;
    name: string | undefined;
    description: string | undefined;
    fileExt: string | undefined;
    sysRefId: number;
    bytes: string | undefined;
}

export class DocumentSysRefLookupTableDto implements IDocumentSysRefLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IDocumentSysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): DocumentSysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentSysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IDocumentSysRefLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfDocumentSysRefLookupTableDto implements IPagedResultDtoOfDocumentSysRefLookupTableDto {
    totalCount!: number;
    items!: DocumentSysRefLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDocumentSysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(DocumentSysRefLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDocumentSysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDocumentSysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDocumentSysRefLookupTableDto {
    totalCount: number;
    items: DocumentSysRefLookupTableDto[] | undefined;
}

export class DocumentProductLookupTableDto implements IDocumentProductLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IDocumentProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): DocumentProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IDocumentProductLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfDocumentProductLookupTableDto implements IPagedResultDtoOfDocumentProductLookupTableDto {
    totalCount!: number;
    items!: DocumentProductLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDocumentProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(DocumentProductLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDocumentProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDocumentProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDocumentProductLookupTableDto {
    totalCount: number;
    items: DocumentProductLookupTableDto[] | undefined;
}

export class DocumentServiceLookupTableDto implements IDocumentServiceLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IDocumentServiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): DocumentServiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentServiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IDocumentServiceLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfDocumentServiceLookupTableDto implements IPagedResultDtoOfDocumentServiceLookupTableDto {
    totalCount!: number;
    items!: DocumentServiceLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDocumentServiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(DocumentServiceLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDocumentServiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDocumentServiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDocumentServiceLookupTableDto {
    totalCount: number;
    items: DocumentServiceLookupTableDto[] | undefined;
}

//#endregion

//#region Emails
@Injectable()
export class EmailsCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReferenceIdFilter (optional) 
     * @param minReferenceIdFilter (optional) 
     * @param emailFromFilter (optional) 
     * @param emailToFilter (optional) 
     * @param emailCCFilter (optional) 
     * @param emailBCCFilter (optional) 
     * @param subjectFilter (optional) 
     * @param bodyFilter (optional) 
     * @param maxRequestDateFilter (optional) 
     * @param minRequestDateFilter (optional) 
     * @param maxSentDateFilter (optional) 
     * @param minSentDateFilter (optional) 
     * @param sysRefTenantIdFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxReferenceIdFilter: number | undefined, minReferenceIdFilter: number | undefined, emailFromFilter: string | undefined, emailToFilter: string | undefined, emailCCFilter: string | undefined, emailBCCFilter: string | undefined, subjectFilter: string | undefined, bodyFilter: string | undefined, maxRequestDateFilter: moment.Moment | undefined, minRequestDateFilter: moment.Moment | undefined, maxSentDateFilter: moment.Moment | undefined, minSentDateFilter: moment.Moment | undefined, sysRefTenantIdFilter: string | undefined, sysStatusNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetEmailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Emails/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReferenceIdFilter === null)
            throw new Error("The parameter 'maxReferenceIdFilter' cannot be null.");
        else if (maxReferenceIdFilter !== undefined)
            url_ += "MaxReferenceIdFilter=" + encodeURIComponent("" + maxReferenceIdFilter) + "&"; 
        if (minReferenceIdFilter === null)
            throw new Error("The parameter 'minReferenceIdFilter' cannot be null.");
        else if (minReferenceIdFilter !== undefined)
            url_ += "MinReferenceIdFilter=" + encodeURIComponent("" + minReferenceIdFilter) + "&"; 
        if (emailFromFilter === null)
            throw new Error("The parameter 'emailFromFilter' cannot be null.");
        else if (emailFromFilter !== undefined)
            url_ += "EmailFromFilter=" + encodeURIComponent("" + emailFromFilter) + "&"; 
        if (emailToFilter === null)
            throw new Error("The parameter 'emailToFilter' cannot be null.");
        else if (emailToFilter !== undefined)
            url_ += "EmailToFilter=" + encodeURIComponent("" + emailToFilter) + "&"; 
        if (emailCCFilter === null)
            throw new Error("The parameter 'emailCCFilter' cannot be null.");
        else if (emailCCFilter !== undefined)
            url_ += "EmailCCFilter=" + encodeURIComponent("" + emailCCFilter) + "&"; 
        if (emailBCCFilter === null)
            throw new Error("The parameter 'emailBCCFilter' cannot be null.");
        else if (emailBCCFilter !== undefined)
            url_ += "EmailBCCFilter=" + encodeURIComponent("" + emailBCCFilter) + "&"; 
        if (subjectFilter === null)
            throw new Error("The parameter 'subjectFilter' cannot be null.");
        else if (subjectFilter !== undefined)
            url_ += "SubjectFilter=" + encodeURIComponent("" + subjectFilter) + "&"; 
        if (bodyFilter === null)
            throw new Error("The parameter 'bodyFilter' cannot be null.");
        else if (bodyFilter !== undefined)
            url_ += "BodyFilter=" + encodeURIComponent("" + bodyFilter) + "&"; 
        if (maxRequestDateFilter === null)
            throw new Error("The parameter 'maxRequestDateFilter' cannot be null.");
        else if (maxRequestDateFilter !== undefined)
            url_ += "MaxRequestDateFilter=" + encodeURIComponent(maxRequestDateFilter ? "" + maxRequestDateFilter.toJSON() : "") + "&"; 
        if (minRequestDateFilter === null)
            throw new Error("The parameter 'minRequestDateFilter' cannot be null.");
        else if (minRequestDateFilter !== undefined)
            url_ += "MinRequestDateFilter=" + encodeURIComponent(minRequestDateFilter ? "" + minRequestDateFilter.toJSON() : "") + "&"; 
        if (maxSentDateFilter === null)
            throw new Error("The parameter 'maxSentDateFilter' cannot be null.");
        else if (maxSentDateFilter !== undefined)
            url_ += "MaxSentDateFilter=" + encodeURIComponent(maxSentDateFilter ? "" + maxSentDateFilter.toJSON() : "") + "&"; 
        if (minSentDateFilter === null)
            throw new Error("The parameter 'minSentDateFilter' cannot be null.");
        else if (minSentDateFilter !== undefined)
            url_ += "MinSentDateFilter=" + encodeURIComponent(minSentDateFilter ? "" + minSentDateFilter.toJSON() : "") + "&"; 
        if (sysRefTenantIdFilter === null)
            throw new Error("The parameter 'sysRefTenantIdFilter' cannot be null.");
        else if (sysRefTenantIdFilter !== undefined)
            url_ += "SysRefTenantIdFilter=" + encodeURIComponent("" + sysRefTenantIdFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetEmailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetEmailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEmailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetEmailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetEmailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmailForView(id: number | undefined): Observable<GetEmailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Emails/GetEmailForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailForView(<any>response_);
                } catch (e) {
                    return <Observable<GetEmailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailForView(response: HttpResponseBase): Observable<GetEmailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmailForEdit(id: number | undefined): Observable<GetEmailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Emails/GetEmailForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEmailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailForEdit(response: HttpResponseBase): Observable<GetEmailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmailForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmailForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditEmailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Emails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Emails/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxReferenceIdFilter (optional) 
     * @param minReferenceIdFilter (optional) 
     * @param emailFromFilter (optional) 
     * @param emailToFilter (optional) 
     * @param emailCCFilter (optional) 
     * @param emailBCCFilter (optional) 
     * @param subjectFilter (optional) 
     * @param bodyFilter (optional) 
     * @param maxRequestDateFilter (optional) 
     * @param minRequestDateFilter (optional) 
     * @param maxSentDateFilter (optional) 
     * @param minSentDateFilter (optional) 
     * @param sysRefTenantIdFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @return Success
     */
    getEmailsToExcel(filter: string | undefined, maxReferenceIdFilter: number | undefined, minReferenceIdFilter: number | undefined, emailFromFilter: string | undefined, emailToFilter: string | undefined, emailCCFilter: string | undefined, emailBCCFilter: string | undefined, subjectFilter: string | undefined, bodyFilter: string | undefined, maxRequestDateFilter: moment.Moment | undefined, minRequestDateFilter: moment.Moment | undefined, maxSentDateFilter: moment.Moment | undefined, minSentDateFilter: moment.Moment | undefined, sysRefTenantIdFilter: string | undefined, sysStatusNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Emails/GetEmailsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReferenceIdFilter === null)
            throw new Error("The parameter 'maxReferenceIdFilter' cannot be null.");
        else if (maxReferenceIdFilter !== undefined)
            url_ += "MaxReferenceIdFilter=" + encodeURIComponent("" + maxReferenceIdFilter) + "&"; 
        if (minReferenceIdFilter === null)
            throw new Error("The parameter 'minReferenceIdFilter' cannot be null.");
        else if (minReferenceIdFilter !== undefined)
            url_ += "MinReferenceIdFilter=" + encodeURIComponent("" + minReferenceIdFilter) + "&"; 
        if (emailFromFilter === null)
            throw new Error("The parameter 'emailFromFilter' cannot be null.");
        else if (emailFromFilter !== undefined)
            url_ += "EmailFromFilter=" + encodeURIComponent("" + emailFromFilter) + "&"; 
        if (emailToFilter === null)
            throw new Error("The parameter 'emailToFilter' cannot be null.");
        else if (emailToFilter !== undefined)
            url_ += "EmailToFilter=" + encodeURIComponent("" + emailToFilter) + "&"; 
        if (emailCCFilter === null)
            throw new Error("The parameter 'emailCCFilter' cannot be null.");
        else if (emailCCFilter !== undefined)
            url_ += "EmailCCFilter=" + encodeURIComponent("" + emailCCFilter) + "&"; 
        if (emailBCCFilter === null)
            throw new Error("The parameter 'emailBCCFilter' cannot be null.");
        else if (emailBCCFilter !== undefined)
            url_ += "EmailBCCFilter=" + encodeURIComponent("" + emailBCCFilter) + "&"; 
        if (subjectFilter === null)
            throw new Error("The parameter 'subjectFilter' cannot be null.");
        else if (subjectFilter !== undefined)
            url_ += "SubjectFilter=" + encodeURIComponent("" + subjectFilter) + "&"; 
        if (bodyFilter === null)
            throw new Error("The parameter 'bodyFilter' cannot be null.");
        else if (bodyFilter !== undefined)
            url_ += "BodyFilter=" + encodeURIComponent("" + bodyFilter) + "&"; 
        if (maxRequestDateFilter === null)
            throw new Error("The parameter 'maxRequestDateFilter' cannot be null.");
        else if (maxRequestDateFilter !== undefined)
            url_ += "MaxRequestDateFilter=" + encodeURIComponent(maxRequestDateFilter ? "" + maxRequestDateFilter.toJSON() : "") + "&"; 
        if (minRequestDateFilter === null)
            throw new Error("The parameter 'minRequestDateFilter' cannot be null.");
        else if (minRequestDateFilter !== undefined)
            url_ += "MinRequestDateFilter=" + encodeURIComponent(minRequestDateFilter ? "" + minRequestDateFilter.toJSON() : "") + "&"; 
        if (maxSentDateFilter === null)
            throw new Error("The parameter 'maxSentDateFilter' cannot be null.");
        else if (maxSentDateFilter !== undefined)
            url_ += "MaxSentDateFilter=" + encodeURIComponent(maxSentDateFilter ? "" + maxSentDateFilter.toJSON() : "") + "&"; 
        if (minSentDateFilter === null)
            throw new Error("The parameter 'minSentDateFilter' cannot be null.");
        else if (minSentDateFilter !== undefined)
            url_ += "MinSentDateFilter=" + encodeURIComponent(minSentDateFilter ? "" + minSentDateFilter.toJSON() : "") + "&"; 
        if (sysRefTenantIdFilter === null)
            throw new Error("The parameter 'sysRefTenantIdFilter' cannot be null.");
        else if (sysRefTenantIdFilter !== undefined)
            url_ += "SysRefTenantIdFilter=" + encodeURIComponent("" + sysRefTenantIdFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysRefForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfEmailSysRefLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Emails/GetAllSysRefForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysRefForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysRefForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEmailSysRefLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEmailSysRefLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysRefForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEmailSysRefLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEmailSysRefLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEmailSysRefLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysStatusForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfEmailSysStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Emails/GetAllSysStatusForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEmailSysStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEmailSysStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEmailSysStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEmailSysStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEmailSysStatusLookupTableDto>(<any>null);
    }
}


export class EmailDto implements IEmailDto {
    referenceId!: number;
    emailFrom!: string | undefined;
    emailTo!: string | undefined;
    emailCC!: string | undefined;
    emailBCC!: string | undefined;
    subject!: string | undefined;
    body!: string | undefined;
    requestDate!: moment.Moment;
    sentDate!: moment.Moment;
    sysRefId!: number | undefined;
    sysStatusId!: number | undefined;
    id!: number;

    constructor(data?: IEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.referenceId = data["referenceId"];
            this.emailFrom = data["emailFrom"];
            this.emailTo = data["emailTo"];
            this.emailCC = data["emailCC"];
            this.emailBCC = data["emailBCC"];
            this.subject = data["subject"];
            this.body = data["body"];
            this.requestDate = data["requestDate"] ? moment(data["requestDate"].toString()) : <any>undefined;
            this.sentDate = data["sentDate"] ? moment(data["sentDate"].toString()) : <any>undefined;
            this.sysRefId = data["sysRefId"];
            this.sysStatusId = data["sysStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceId"] = this.referenceId;
        data["emailFrom"] = this.emailFrom;
        data["emailTo"] = this.emailTo;
        data["emailCC"] = this.emailCC;
        data["emailBCC"] = this.emailBCC;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["sentDate"] = this.sentDate ? this.sentDate.toISOString() : <any>undefined;
        data["sysRefId"] = this.sysRefId;
        data["sysStatusId"] = this.sysStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEmailDto {
    referenceId: number;
    emailFrom: string | undefined;
    emailTo: string | undefined;
    emailCC: string | undefined;
    emailBCC: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    requestDate: moment.Moment;
    sentDate: moment.Moment;
    sysRefId: number | undefined;
    sysStatusId: number | undefined;
    id: number;
}

export class GetEmailForViewDto implements IGetEmailForViewDto {
    email!: EmailDto;
    sysRefTenantId!: string | undefined;
    sysStatusName!: string | undefined;

    constructor(data?: IGetEmailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"] ? EmailDto.fromJS(data["email"]) : <any>undefined;
            this.sysRefTenantId = data["sysRefTenantId"];
            this.sysStatusName = data["sysStatusName"];
        }
    }

    static fromJS(data: any): GetEmailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["sysRefTenantId"] = this.sysRefTenantId;
        data["sysStatusName"] = this.sysStatusName;
        return data; 
    }
}

export interface IGetEmailForViewDto {
    email: EmailDto;
    sysRefTenantId: string | undefined;
    sysStatusName: string | undefined;
}

export class PagedResultDtoOfGetEmailForViewDto implements IPagedResultDtoOfGetEmailForViewDto {
    totalCount!: number;
    items!: GetEmailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEmailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetEmailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEmailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEmailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetEmailForViewDto {
    totalCount: number;
    items: GetEmailForViewDto[] | undefined;
}

export class CreateOrEditEmailDto implements ICreateOrEditEmailDto {
    referenceId!: number;
    emailFrom!: string | undefined;
    emailTo!: string | undefined;
    emailCC!: string | undefined;
    emailBCC!: string | undefined;
    subject!: string | undefined;
    body!: string | undefined;
    requestDate!: moment.Moment;
    sentDate!: moment.Moment;
    sysRefId!: number | undefined;
    sysStatusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.referenceId = data["referenceId"];
            this.emailFrom = data["emailFrom"];
            this.emailTo = data["emailTo"];
            this.emailCC = data["emailCC"];
            this.emailBCC = data["emailBCC"];
            this.subject = data["subject"];
            this.body = data["body"];
            this.requestDate = data["requestDate"] ? moment(data["requestDate"].toString()) : <any>undefined;
            this.sentDate = data["sentDate"] ? moment(data["sentDate"].toString()) : <any>undefined;
            this.sysRefId = data["sysRefId"];
            this.sysStatusId = data["sysStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceId"] = this.referenceId;
        data["emailFrom"] = this.emailFrom;
        data["emailTo"] = this.emailTo;
        data["emailCC"] = this.emailCC;
        data["emailBCC"] = this.emailBCC;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["sentDate"] = this.sentDate ? this.sentDate.toISOString() : <any>undefined;
        data["sysRefId"] = this.sysRefId;
        data["sysStatusId"] = this.sysStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditEmailDto {
    referenceId: number;
    emailFrom: string | undefined;
    emailTo: string | undefined;
    emailCC: string | undefined;
    emailBCC: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    requestDate: moment.Moment;
    sentDate: moment.Moment;
    sysRefId: number | undefined;
    sysStatusId: number | undefined;
    id: number | undefined;
}

export class GetEmailForEditOutput implements IGetEmailForEditOutput {
    email!: CreateOrEditEmailDto;
    sysRefTenantId!: string | undefined;
    sysStatusName!: string | undefined;

    constructor(data?: IGetEmailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"] ? CreateOrEditEmailDto.fromJS(data["email"]) : <any>undefined;
            this.sysRefTenantId = data["sysRefTenantId"];
            this.sysStatusName = data["sysStatusName"];
        }
    }

    static fromJS(data: any): GetEmailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["sysRefTenantId"] = this.sysRefTenantId;
        data["sysStatusName"] = this.sysStatusName;
        return data; 
    }
}

export interface IGetEmailForEditOutput {
    email: CreateOrEditEmailDto;
    sysRefTenantId: string | undefined;
    sysStatusName: string | undefined;
}

export class EmailSysRefLookupTableDto implements IEmailSysRefLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IEmailSysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): EmailSysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IEmailSysRefLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfEmailSysRefLookupTableDto implements IPagedResultDtoOfEmailSysRefLookupTableDto {
    totalCount!: number;
    items!: EmailSysRefLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEmailSysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EmailSysRefLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEmailSysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEmailSysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEmailSysRefLookupTableDto {
    totalCount: number;
    items: EmailSysRefLookupTableDto[] | undefined;
}

export class EmailSysStatusLookupTableDto implements IEmailSysStatusLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IEmailSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): EmailSysStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IEmailSysStatusLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfEmailSysStatusLookupTableDto implements IPagedResultDtoOfEmailSysStatusLookupTableDto {
    totalCount!: number;
    items!: EmailSysStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEmailSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EmailSysStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEmailSysStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEmailSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEmailSysStatusLookupTableDto {
    totalCount: number;
    items: EmailSysStatusLookupTableDto[] | undefined;
}


//#endregion Emails

//#region Other Interface
export interface CustomTreeNode {
    label?: string;
    data?: any;
    icon?: any;
    expandedIcon?: any;
    collapsedIcon?: any;
    children?: CustomTreeNode[];
    leaf?: boolean;
    expanded?: boolean;
    type?: string;
    parent?: CustomTreeNode;
    partialSelected?: boolean;
    styleClass?: string;
    draggable?: boolean;
    droppable?: boolean;
    selectable?: boolean;
    key?: string;
    teamMemberId?: any;
    reportingTeamMemberId?: any;
    emailAddress?: string;
}
//#endregion

//#region ParamSetting

@Injectable()
export class ParamSettingsCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param nameFilter (optional)
     * @param valueFilter (optional)
     * @param descriptionFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(
        filter: string | undefined,
        nameFilter: string | undefined,
        valueFilter: string | undefined,
        descriptionFilter: string | undefined,
        sorting: string | undefined,
        skipCount: number | undefined,
        maxResultCount: number | undefined
    ): Observable<PagedResultDtoOfGetParamSettingForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonQuery/GetParamSetting_All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (valueFilter === null)
            throw new Error("The parameter 'valueFilter' cannot be null.");
        else if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&";
        if (descriptionFilter === null)
            throw new Error(
                "The parameter 'descriptionFilter' cannot be null."
            );
        else if (descriptionFilter !== undefined)
            url_ +=
                "DescriptionFilter=" +
                encodeURIComponent("" + descriptionFilter) +
                "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ +=
                "MaxResultCount=" +
                encodeURIComponent("" + maxResultCount) +
                "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCustomGetAll(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCustomGetAll(<any>response_);
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfGetParamSettingForViewDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<
                                PagedResultDtoOfGetParamSettingForViewDto
                            >
                        >(<any>_observableThrow(response_));
                })
            );
    }

    protected processCustomGetAll(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfGetParamSettingForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfGetParamSettingForViewDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfGetParamSettingForViewDto>(
            <any>null
        );
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getParamSettingForView(id: number | undefined): Observable<GetParamSettingForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ParamSettings/GetParamSettingForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParamSettingForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParamSettingForView(<any>response_);
                } catch (e) {
                    return <Observable<GetParamSettingForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetParamSettingForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetParamSettingForView(response: HttpResponseBase): Observable<GetParamSettingForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetParamSettingForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetParamSettingForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getParamSettingForEdit(id: number | undefined): Observable<GetParamSettingForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ParamSettings/GetParamSettingForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParamSettingForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParamSettingForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetParamSettingForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetParamSettingForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetParamSettingForEdit(response: HttpResponseBase): Observable<GetParamSettingForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetParamSettingForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetParamSettingForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditParamSettingDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ParamSettings/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ParamSettings/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param valueFilter (optional) 
     * @param descriptionFilter (optional) 
     * @return Success
     */
    getParamSettingsToExcel(filter: string | undefined, nameFilter: string | undefined, valueFilter: string | undefined, descriptionFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ParamSettings/GetParamSettingsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (valueFilter === null)
            throw new Error("The parameter 'valueFilter' cannot be null.");
        else if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParamSettingsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParamSettingsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetParamSettingsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

export class PagedResultDtoOfGetParamSettingForViewDto
    implements IPagedResultDtoOfGetParamSettingForViewDto {
    totalCount!: number;
    items!: GetParamSettingForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetParamSettingForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetParamSettingForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetParamSettingForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfGetParamSettingForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}


export class CreateOrEditParamSettingDto implements ICreateOrEditParamSettingDto {
    name!: string | undefined;
    value!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditParamSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditParamSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditParamSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditParamSettingDto {
    name: string | undefined;
    value: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export interface IPagedResultDtoOfGetParamSettingForViewDto {
    totalCount: number;
    items: GetParamSettingForViewDto[] | undefined;
}

export class GetParamSettingForViewDto implements IGetParamSettingForViewDto {
    paramSetting!: ParamSettingDto;

    constructor(data?: IGetParamSettingForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paramSetting = data["paramSetting"]
                ? ParamSettingDto.fromJS(data["paramSetting"])
                : <any>undefined;
        }
    }

    static fromJS(data: any): GetParamSettingForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new GetParamSettingForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["paramSetting"] = this.paramSetting
            ? this.paramSetting.toJSON()
            : <any>undefined;
        return data;
    }
}

export interface IGetParamSettingForViewDto {
    paramSetting: ParamSettingDto;
}

export class ParamSettingDto implements IParamSettingDto {
    name!: string | undefined;
    value!: string | undefined;
    description!: string | undefined;
    id!: number;
    boolValue!: boolean | undefined;

    constructor(data?: IParamSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
            this.description = data["description"];
            this.id = data["id"];
            if (data["value"].toLowerCase() != null) {
                if (data["value"].toLowerCase() == "false") {
                    data["boolValue"] = false;
                } else if (data["value"].toLowerCase() == "true") {
                    data["boolValue"] = true;
                }
            }
            this.boolValue = data["boolValue"];
        }
    }

    static fromJS(data: any): ParamSettingDto {
        data = typeof data === "object" ? data : {};
        let result = new ParamSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        if (this.boolValue != null) {
            if (this.boolValue == false) {
                data["value"] = "false";
            } else {
                data["value"] = "true";
            }
        }
        return data;
    }
}

export interface IParamSettingDto {
    name: string | undefined;
    value: string | undefined;
    description: string | undefined;
    id: number;
    boolValue: boolean | undefined;
}

export interface IParamSettingDto {
    name: string | undefined;
    value: string | undefined;
    description: string | undefined;
    id: number;
}

export interface IGetParamSettingForViewDto {
    paramSetting: ParamSettingDto;
}

export interface ICreateOrEditParamSettingDto {
    name: string | undefined;
    value: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetParamSettingForEditOutput implements IGetParamSettingForEditOutput {
    paramSetting!: CreateOrEditParamSettingDto;

    constructor(data?: IGetParamSettingForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paramSetting = data["paramSetting"] ? CreateOrEditParamSettingDto.fromJS(data["paramSetting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetParamSettingForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetParamSettingForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paramSetting"] = this.paramSetting ? this.paramSetting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetParamSettingForEditOutput {
    paramSetting: CreateOrEditParamSettingDto;
}

export class FileDto implements IFileDto {
    fileName!: string | undefined;
    fileType!: string | undefined;
    fileToken!: string | undefined;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string | undefined;
    fileType: string | undefined;
    fileToken: string | undefined;
}

//#endregion

//#region Product
@Injectable()
export class ProductsCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxStockFilter (optional) 
     * @param minStockFilter (optional) 
     * @param uomFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param categoryNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, maxStockFilter: number | undefined, minStockFilter: number | undefined, uomFilter: string | undefined, isApprovedFilter: number | undefined, isActiveFilter: number | undefined, categoryNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetProductForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxStockFilter === null)
            throw new Error("The parameter 'maxStockFilter' cannot be null.");
        else if (maxStockFilter !== undefined)
            url_ += "MaxStockFilter=" + encodeURIComponent("" + maxStockFilter) + "&"; 
        if (minStockFilter === null)
            throw new Error("The parameter 'minStockFilter' cannot be null.");
        else if (minStockFilter !== undefined)
            url_ += "MinStockFilter=" + encodeURIComponent("" + minStockFilter) + "&"; 
        if (uomFilter === null)
            throw new Error("The parameter 'uomFilter' cannot be null.");
        else if (uomFilter !== undefined)
            url_ += "UomFilter=" + encodeURIComponent("" + uomFilter) + "&"; 
        if (isApprovedFilter === null)
            throw new Error("The parameter 'isApprovedFilter' cannot be null.");
        else if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (categoryNameFilter === null)
            throw new Error("The parameter 'categoryNameFilter' cannot be null.");
        else if (categoryNameFilter !== undefined)
            url_ += "CategoryNameFilter=" + encodeURIComponent("" + categoryNameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetProductForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetProductForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetProductForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetProductForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetProductForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductForView(id: number | undefined): Observable<GetProductForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetProductForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductForView(<any>response_);
                } catch (e) {
                    return <Observable<GetProductForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProductForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductForView(response: HttpResponseBase): Observable<GetProductForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProductForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductForEdit(id: number | undefined): Observable<GetProductForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetProductForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetProductForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProductForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductForEdit(response: HttpResponseBase): Observable<GetProductForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProductForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditProductDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Products/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Products/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxStockFilter (optional) 
     * @param minStockFilter (optional) 
     * @param uomFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param categoryNameFilter (optional) 
     * @return Success
     */
    getProductsToExcel(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, maxStockFilter: number | undefined, minStockFilter: number | undefined, uomFilter: string | undefined, isApprovedFilter: number | undefined, isActiveFilter: number | undefined, categoryNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetProductsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxStockFilter === null)
            throw new Error("The parameter 'maxStockFilter' cannot be null.");
        else if (maxStockFilter !== undefined)
            url_ += "MaxStockFilter=" + encodeURIComponent("" + maxStockFilter) + "&"; 
        if (minStockFilter === null)
            throw new Error("The parameter 'minStockFilter' cannot be null.");
        else if (minStockFilter !== undefined)
            url_ += "MinStockFilter=" + encodeURIComponent("" + minStockFilter) + "&"; 
        if (uomFilter === null)
            throw new Error("The parameter 'uomFilter' cannot be null.");
        else if (uomFilter !== undefined)
            url_ += "UomFilter=" + encodeURIComponent("" + uomFilter) + "&"; 
        if (isApprovedFilter === null)
            throw new Error("The parameter 'isApprovedFilter' cannot be null.");
        else if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (categoryNameFilter === null)
            throw new Error("The parameter 'categoryNameFilter' cannot be null.");
        else if (categoryNameFilter !== undefined)
            url_ += "CategoryNameFilter=" + encodeURIComponent("" + categoryNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetAllCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategoryForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductCategoryLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductCategoryLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductCategoryLookupTableDto>(<any>null);
    }
}

export class PagedResultDtoOfProductCategoryLookupTableDto implements IPagedResultDtoOfProductCategoryLookupTableDto {
    totalCount!: number;
    items!: ProductCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProductCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProductCategoryLookupTableDto {
    totalCount: number;
    items: ProductCategoryLookupTableDto[] | undefined;
}

export class ProductDto implements IProductDto {
    name!: string | undefined;
    description!: string | undefined;
    stock!: number;
    uom!: string | undefined;
    isApproved!: boolean;
    isActive!: boolean;
    remark!: string | undefined;
    categoryId!: number | undefined;
    id!: number;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.stock = data["stock"];
            this.uom = data["uom"];
            this.isApproved = data["isApproved"];
            this.isActive = data["isActive"];
            this.remark = data["remark"];
            this.categoryId = data["categoryId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["stock"] = this.stock;
        data["uom"] = this.uom;
        data["isApproved"] = this.isApproved;
        data["isActive"] = this.isActive;
        data["remark"] = this.remark;
        data["categoryId"] = this.categoryId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProductDto {
    name: string | undefined;
    description: string | undefined;
    stock: number;
    uom: string | undefined;
    isApproved: boolean;
    isActive: boolean;
    remark: string | undefined;
    categoryId: number | undefined;
    id: number;
}

export class GetProductForViewDto implements IGetProductForViewDto {
    product!: ProductDto;
    categoryName!: string | undefined;

    constructor(data?: IGetProductForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.product = data["product"] ? ProductDto.fromJS(data["product"]) : <any>undefined;
            this.categoryName = data["categoryName"];
        }
    }

    static fromJS(data: any): GetProductForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["categoryName"] = this.categoryName;
        return data; 
    }
}

export interface IGetProductForViewDto {
    product: ProductDto;
    categoryName: string | undefined;
}

export class PagedResultDtoOfGetProductForViewDto implements IPagedResultDtoOfGetProductForViewDto {
    totalCount!: number;
    items!: GetProductForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetProductForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetProductForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetProductForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetProductForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetProductForViewDto {
    totalCount: number;
    items: GetProductForViewDto[] | undefined;
}

export class CreateOrEditProductDto implements ICreateOrEditProductDto {
    name!: string | undefined;
    description!: string | undefined;
    stock!: number;
    uom!: string | undefined;
    isApproved!: boolean;
    isActive!: boolean;
    remark!: string | undefined;
    categoryId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.stock = data["stock"];
            this.uom = data["uom"];
            this.isApproved = data["isApproved"];
            this.isActive = data["isActive"];
            this.remark = data["remark"];
            this.categoryId = data["categoryId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["stock"] = this.stock;
        data["uom"] = this.uom;
        data["isApproved"] = this.isApproved;
        data["isActive"] = this.isActive;
        data["remark"] = this.remark;
        data["categoryId"] = this.categoryId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditProductDto {
    name: string | undefined;
    description: string | undefined;
    stock: number;
    uom: string | undefined;
    isApproved: boolean;
    isActive: boolean;
    remark: string | undefined;
    categoryId: number | undefined;
    id: number | undefined;
}

export class GetProductForEditOutput implements IGetProductForEditOutput {
    product!: CreateOrEditProductDto;
    categoryName!: string | undefined;

    constructor(data?: IGetProductForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.product = data["product"] ? CreateOrEditProductDto.fromJS(data["product"]) : <any>undefined;
            this.categoryName = data["categoryName"];
        }
    }

    static fromJS(data: any): GetProductForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["categoryName"] = this.categoryName;
        return data; 
    }
}

export interface IGetProductForEditOutput {
    product: CreateOrEditProductDto;
    categoryName: string | undefined;
}

export class ProductCategoryLookupTableDto implements IProductCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ProductCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IProductCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}
//#endregion

//#region Product Images
@Injectable()
export class ProductImagesCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param urlFilter (optional) 
     * @param isMainFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param productNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, descriptionFilter: string | undefined, urlFilter: string | undefined, isMainFilter: number | undefined, isApprovedFilter: number | undefined, productNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetProductImageForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductImages/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&"; 
        if (isMainFilter === null)
            throw new Error("The parameter 'isMainFilter' cannot be null.");
        else if (isMainFilter !== undefined)
            url_ += "IsMainFilter=" + encodeURIComponent("" + isMainFilter) + "&"; 
        if (isApprovedFilter === null)
            throw new Error("The parameter 'isApprovedFilter' cannot be null.");
        else if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetProductImageForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetProductImageForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetProductImageForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetProductImageForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetProductImageForViewDto>(<any>null);
    }

    /**
     * @param productId
     * @return Success
     */
    getProductImagesByProductId(
        productId: number | undefined
    ): Observable<PagedResultDtoOfGetProductImageForViewDto> {
        let url_ =
            this.baseUrl +
            "/api/services/app/ProductImages/GetProductImagesByProductId?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };
        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetProductImagesByProductId(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetProductImagesByProductId(
                                <any>response_
                            );
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfGetProductImageForViewDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<
                                PagedResultDtoOfGetProductImageForViewDto
                            >
                        >(<any>_observableThrow(response_));
                })
            );
    }
    protected processGetProductImagesByProductId(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfGetProductImageForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfGetProductImageForViewDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfGetProductImageForViewDto>(
            <any>null
        );
    }

    /**
     * @param body (optional)
     * @return Success
     */
    updateProductImages(
        body: UpdateProductImagesInput | undefined
    ): Observable<void> {
        let url_ =
            this.baseUrl +
            "/api/services/app/ProductImages/UpdateProductImages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json"
            })
        };

        return this.http
            .request("put", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateProductImages(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateProductImages(
                                <any>response_
                            );
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else
                        return <Observable<void>>(
                            (<any>_observableThrow(response_))
                        );
                })
            );
    }

    protected processUpdateProductImages(
        response: HttpResponseBase
    ): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    getProductImageForEdit(id: number | undefined): Observable<GetProductImageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ProductImages/GetProductImageForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductImageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductImageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetProductImageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProductImageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductImageForEdit(response: HttpResponseBase): Observable<GetProductImageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductImageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProductImageForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditProductImageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductImages/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductImages/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param urlFilter (optional) 
     * @param isMainFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param productNameFilter (optional) 
     * @return Success
     */
    getProductImagesToExcel(filter: string | undefined, descriptionFilter: string | undefined, urlFilter: string | undefined, isMainFilter: number | undefined, isApprovedFilter: number | undefined, productNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductImages/GetProductImagesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&"; 
        if (isMainFilter === null)
            throw new Error("The parameter 'isMainFilter' cannot be null.");
        else if (isMainFilter !== undefined)
            url_ += "IsMainFilter=" + encodeURIComponent("" + isMainFilter) + "&"; 
        if (isApprovedFilter === null)
            throw new Error("The parameter 'isApprovedFilter' cannot be null.");
        else if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductImagesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductImagesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductImagesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProductForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductImageProductLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductImages/GetAllProductForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductImageProductLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductImageProductLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductImageProductLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductImageProductLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductImageProductLookupTableDto>(<any>null);
    }
}

export class UpdateProductImagesInput implements IUpdateProductImagesInput {
    fileToken!: string | undefined;
    x!: number;
    y!: number;
    width!: number;
    height!: number;
    productId!: number;
    fileName!: string | undefined;
    description!: string | undefined;
    fileType!: string | undefined;
    bytes!: string | undefined;

    constructor(data?: IUpdateProductImagesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
            this.productId = data["productId"];
            this.fileName = data["fileName"];
            this.description = data["description"];
            this.fileType = data["fileType"];
            this.bytes = data["bytes"];
        }
    }

    static fromJS(data: any): UpdateProductImagesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductImagesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        data["productId"] = this.productId;
        data["fileName"] = this.fileName;
        data["description"] = this.description;
        data["fileType"] = this.fileType;
        data["bytes"] = this.bytes;
        return data; 
    }
}

export interface IUpdateProductImagesInput {
    fileToken: string | undefined;
    x: number;
    y: number;
    width: number;
    height: number;
    productId: number;
    fileName: string | undefined;
    description: string | undefined;
    fileType: string | undefined;
    bytes: string | undefined;
}

export class ProductImageDto implements IProductImageDto {
    description!: string | undefined;
    url!: string | undefined;
    isMain!: boolean;
    isApproved!: boolean;
    productId!: number | undefined;
    bytes!: string | undefined;
    fileName!: string | undefined;
    fileType!: string | undefined;
    imageBase64String!: string | undefined;
    id!: number;

    constructor(data?: IProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.url = data["url"];
            this.isMain = data["isMain"];
            this.isApproved = data["isApproved"];
            this.productId = data["productId"];
            this.bytes = data["bytes"];
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.imageBase64String = data["imageBase64String"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["url"] = this.url;
        data["isMain"] = this.isMain;
        data["isApproved"] = this.isApproved;
        data["productId"] = this.productId;
        data["bytes"] = this.bytes;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["imageBase64String"] = this.imageBase64String;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProductImageDto {
    description: string | undefined;
    url: string | undefined;
    isMain: boolean;
    isApproved: boolean;
    productId: number | undefined;
    bytes: string | undefined;
    fileName: string | undefined;
    fileType: string | undefined;
    imageBase64String: string | undefined;
    id: number;
}
export interface ICreateOrEditProductImageDto {
    description: string | undefined;
    url: string | undefined;
    isMain: boolean;
    isApproved: boolean;
    productId: number | undefined;
    id: number | undefined;
}

export interface IGetProductImageForViewDto {
    productImage: ProductImageDto;
    productName: string | undefined;
}

export class ProductImage {
    imageBase64String: string;
    imageId: number;
    fileDescr: string;
    url: string;
    isMain: boolean;
}
export interface IPagedResultDtoOfGetProductImageForViewDto {
    totalCount: number;
    items: GetProductImageForViewDto[] | undefined;
}

export class CreateOrEditProductImageDto
    implements ICreateOrEditProductImageDto {
    description!: string | undefined;
    url!: string | undefined;
    isMain!: boolean;
    isApproved!: boolean;
    productId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.url = data["url"];
            this.isMain = data["isMain"];
            this.isApproved = data["isApproved"];
            this.productId = data["productId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditProductImageDto {
        data = typeof data === "object" ? data : {};
        let result = new CreateOrEditProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["description"] = this.description;
        data["url"] = this.url;
        data["isMain"] = this.isMain;
        data["isApproved"] = this.isApproved;
        data["productId"] = this.productId;
        data["id"] = this.id;
        return data;
    }
}

export class GetProductImageForViewDto implements IGetProductImageForViewDto {
    productImage!: ProductImageDto;
    productName!: string | undefined;

    constructor(data?: IGetProductImageForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productImage = data["productImage"]
                ? ProductImageDto.fromJS(data["productImage"])
                : <any>undefined;
            this.productName = data["productName"];
        }
    }

    static fromJS(data: any): GetProductImageForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new GetProductImageForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["productImage"] = this.productImage
            ? this.productImage.toJSON()
            : <any>undefined;
        data["productName"] = this.productName;
        return data;
    }
}

export class PagedResultDtoOfGetProductImageForViewDto
    implements IPagedResultDtoOfGetProductImageForViewDto {
    totalCount!: number;
    items!: GetProductImageForViewDto[] | undefined;
    productImageList: ProductImage[] = [];

    constructor(data?: IPagedResultDtoOfGetProductImageForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;

                for (let item of data["items"]) {
                    var productImage = new ProductImage();
                    productImage.imageBase64String =
                        "data:image/jpeg;base64," +
                        item.productImage.imageBase64String;
                    productImage.imageId = item.productImage.id;
                    productImage.fileDescr = item.productImage.description;
                    productImage.isMain = item.productImage.isMain;
                    productImage.url = item.productImage.url;

                    this.productImageList.push(productImage);
                    this.items!.push(GetProductImageForViewDto.fromJS(item));
                }
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetProductImageForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfGetProductImageForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}


export interface IProductImageDto {
    description: string | undefined;
    url: string | undefined;
    isMain: boolean;
    isApproved: boolean;
    productId: number | undefined;
    bytes: string | undefined;
    fileName: string | undefined;
    fileType: string | undefined;
    imageBase64String: string | undefined;
    id: number;
}


export interface IGetProductImageForViewDto {
    productImage: ProductImageDto;
    productName: string | undefined;
}

export interface IPagedResultDtoOfGetProductImageForViewDto {
    totalCount: number;
    items: GetProductImageForViewDto[] | undefined;
}

export class GetProductImageForEditOutput implements IGetProductImageForEditOutput {
    productImage!: CreateOrEditProductImageDto;
    productName!: string | undefined;

    constructor(data?: IGetProductImageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productImage = data["productImage"] ? CreateOrEditProductImageDto.fromJS(data["productImage"]) : <any>undefined;
            this.productName = data["productName"];
        }
    }

    static fromJS(data: any): GetProductImageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductImageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productImage"] = this.productImage ? this.productImage.toJSON() : <any>undefined;
        data["productName"] = this.productName;
        return data; 
    }
}

export interface IGetProductImageForEditOutput {
    productImage: CreateOrEditProductImageDto;
    productName: string | undefined;
}


export interface IUpdateProductImagesInput {
    fileToken: string | undefined;
    x: number;
    y: number;
    width: number;
    height: number;
    productId: number;
    fileName: string | undefined;
    description: string | undefined;
    fileType: string | undefined;
    bytes: string | undefined;
}

export class ProductImageProductLookupTableDto implements IProductImageProductLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductImageProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ProductImageProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IProductImageProductLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfProductImageProductLookupTableDto implements IPagedResultDtoOfProductImageProductLookupTableDto {
    totalCount!: number;
    items!: ProductImageProductLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductImageProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProductImageProductLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductImageProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductImageProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProductImageProductLookupTableDto {
    totalCount: number;
    items: ProductImageProductLookupTableDto[] | undefined;
}

//#endregion

//#region Project
@Injectable()
export class ProjectsCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param isApproveFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param publishFilter (optional) 
     * @param remarkFilter (optional) 
     * @param accountNameFilter (optional) 
     * @param teamNameFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, maxStartDateFilter: moment.Moment | undefined, minStartDateFilter: moment.Moment | undefined, maxEndDateFilter: moment.Moment | undefined, minEndDateFilter: moment.Moment | undefined, isApproveFilter: number | undefined, isActiveFilter: number | undefined, publishFilter: number | undefined, remarkFilter: string | undefined, accountNameFilter: string | undefined, teamNameFilter: string | undefined, sysStatusNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetProjectForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Projects/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (isApproveFilter === null)
            throw new Error("The parameter 'isApproveFilter' cannot be null.");
        else if (isApproveFilter !== undefined)
            url_ += "IsApproveFilter=" + encodeURIComponent("" + isApproveFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (publishFilter === null)
            throw new Error("The parameter 'publishFilter' cannot be null.");
        else if (publishFilter !== undefined)
            url_ += "PublishFilter=" + encodeURIComponent("" + publishFilter) + "&"; 
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (accountNameFilter === null)
            throw new Error("The parameter 'accountNameFilter' cannot be null.");
        else if (accountNameFilter !== undefined)
            url_ += "AccountNameFilter=" + encodeURIComponent("" + accountNameFilter) + "&"; 
        if (teamNameFilter === null)
            throw new Error("The parameter 'teamNameFilter' cannot be null.");
        else if (teamNameFilter !== undefined)
            url_ += "TeamNameFilter=" + encodeURIComponent("" + teamNameFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetProjectForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetProjectForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetProjectForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetProjectForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetProjectForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProjectForView(id: number | undefined): Observable<GetProjectForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Projects/GetProjectForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectForView(<any>response_);
                } catch (e) {
                    return <Observable<GetProjectForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProjectForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectForView(response: HttpResponseBase): Observable<GetProjectForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProjectForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProjectForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProjectForEdit(id: number | undefined): Observable<GetProjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Projects/GetProjectForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetProjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectForEdit(response: HttpResponseBase): Observable<GetProjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProjectForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditProjectDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Projects/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Projects/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param isApproveFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param publishFilter (optional) 
     * @param remarkFilter (optional) 
     * @param accountNameFilter (optional) 
     * @param teamNameFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @return Success
     */
    getProjectsToExcel(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, maxStartDateFilter: moment.Moment | undefined, minStartDateFilter: moment.Moment | undefined, maxEndDateFilter: moment.Moment | undefined, minEndDateFilter: moment.Moment | undefined, isApproveFilter: number | undefined, isActiveFilter: number | undefined, publishFilter: number | undefined, remarkFilter: string | undefined, accountNameFilter: string | undefined, teamNameFilter: string | undefined, sysStatusNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Projects/GetProjectsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (isApproveFilter === null)
            throw new Error("The parameter 'isApproveFilter' cannot be null.");
        else if (isApproveFilter !== undefined)
            url_ += "IsApproveFilter=" + encodeURIComponent("" + isApproveFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (publishFilter === null)
            throw new Error("The parameter 'publishFilter' cannot be null.");
        else if (publishFilter !== undefined)
            url_ += "PublishFilter=" + encodeURIComponent("" + publishFilter) + "&"; 
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (accountNameFilter === null)
            throw new Error("The parameter 'accountNameFilter' cannot be null.");
        else if (accountNameFilter !== undefined)
            url_ += "AccountNameFilter=" + encodeURIComponent("" + accountNameFilter) + "&"; 
        if (teamNameFilter === null)
            throw new Error("The parameter 'teamNameFilter' cannot be null.");
        else if (teamNameFilter !== undefined)
            url_ += "TeamNameFilter=" + encodeURIComponent("" + teamNameFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAccountForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProjectAccountLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Projects/GetAllAccountForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccountForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProjectAccountLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProjectAccountLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAccountForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProjectAccountLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProjectAccountLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProjectAccountLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTeamForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProjectTeamLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Projects/GetAllTeamForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeamForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeamForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProjectTeamLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProjectTeamLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTeamForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProjectTeamLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProjectTeamLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProjectTeamLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysStatusForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProjectSysStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Projects/GetAllSysStatusForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProjectSysStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProjectSysStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProjectSysStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProjectSysStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProjectSysStatusLookupTableDto>(<any>null);
    }
}

export class ProjectDto implements IProjectDto {
    name!: string | undefined;
    description!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isApprove!: boolean;
    isActive!: boolean;
    publish!: boolean;
    remark!: string | undefined;
    accountId!: number | undefined;
    teamId!: number | undefined;
    sysStatusId!: number | undefined;
    id!: number;

    constructor(data?: IProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isApprove = data["isApprove"];
            this.isActive = data["isActive"];
            this.publish = data["publish"];
            this.remark = data["remark"];
            this.accountId = data["accountId"];
            this.teamId = data["teamId"];
            this.sysStatusId = data["sysStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isApprove"] = this.isApprove;
        data["isActive"] = this.isActive;
        data["publish"] = this.publish;
        data["remark"] = this.remark;
        data["accountId"] = this.accountId;
        data["teamId"] = this.teamId;
        data["sysStatusId"] = this.sysStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProjectDto {
    name: string | undefined;
    description: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isApprove: boolean;
    isActive: boolean;
    publish: boolean;
    remark: string | undefined;
    accountId: number | undefined;
    teamId: number | undefined;
    sysStatusId: number | undefined;
    id: number;
}

export class GetProjectForViewDto implements IGetProjectForViewDto {
    project!: ProjectDto;
    accountName!: string | undefined;
    teamName!: string | undefined;
    sysStatusName!: string | undefined;

    constructor(data?: IGetProjectForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.project = data["project"] ? ProjectDto.fromJS(data["project"]) : <any>undefined;
            this.accountName = data["accountName"];
            this.teamName = data["teamName"];
            this.sysStatusName = data["sysStatusName"];
        }
    }

    static fromJS(data: any): GetProjectForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProjectForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["accountName"] = this.accountName;
        data["teamName"] = this.teamName;
        data["sysStatusName"] = this.sysStatusName;
        return data; 
    }
}

export interface IGetProjectForViewDto {
    project: ProjectDto;
    accountName: string | undefined;
    teamName: string | undefined;
    sysStatusName: string | undefined;
}

export class PagedResultDtoOfGetProjectForViewDto implements IPagedResultDtoOfGetProjectForViewDto {
    totalCount!: number;
    items!: GetProjectForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetProjectForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetProjectForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetProjectForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetProjectForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetProjectForViewDto {
    totalCount: number;
    items: GetProjectForViewDto[] | undefined;
}

export class CreateOrEditProjectDto implements ICreateOrEditProjectDto {
    name!: string | undefined;
    description!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isApprove!: boolean;
    isActive!: boolean;
    publish!: boolean;
    remark!: string | undefined;
    accountId!: number | undefined;
    teamId!: number | undefined;
    sysStatusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isApprove = data["isApprove"];
            this.isActive = data["isActive"];
            this.publish = data["publish"];
            this.remark = data["remark"];
            this.accountId = data["accountId"];
            this.teamId = data["teamId"];
            this.sysStatusId = data["sysStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isApprove"] = this.isApprove;
        data["isActive"] = this.isActive;
        data["publish"] = this.publish;
        data["remark"] = this.remark;
        data["accountId"] = this.accountId;
        data["teamId"] = this.teamId;
        data["sysStatusId"] = this.sysStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditProjectDto {
    name: string | undefined;
    description: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isApprove: boolean;
    isActive: boolean;
    publish: boolean;
    remark: string | undefined;
    accountId: number | undefined;
    teamId: number | undefined;
    sysStatusId: number | undefined;
    id: number | undefined;
}

export class GetProjectForEditOutput implements IGetProjectForEditOutput {
    project!: CreateOrEditProjectDto;
    accountName!: string | undefined;
    teamName!: string | undefined;
    sysStatusName!: string | undefined;

    constructor(data?: IGetProjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.project = data["project"] ? CreateOrEditProjectDto.fromJS(data["project"]) : <any>undefined;
            this.accountName = data["accountName"];
            this.teamName = data["teamName"];
            this.sysStatusName = data["sysStatusName"];
        }
    }

    static fromJS(data: any): GetProjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["accountName"] = this.accountName;
        data["teamName"] = this.teamName;
        data["sysStatusName"] = this.sysStatusName;
        return data; 
    }
}

export interface IGetProjectForEditOutput {
    project: CreateOrEditProjectDto;
    accountName: string | undefined;
    teamName: string | undefined;
    sysStatusName: string | undefined;
}

export class ProjectAccountLookupTableDto implements IProjectAccountLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProjectAccountLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ProjectAccountLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectAccountLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IProjectAccountLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfProjectAccountLookupTableDto implements IPagedResultDtoOfProjectAccountLookupTableDto {
    totalCount!: number;
    items!: ProjectAccountLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProjectAccountLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProjectAccountLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProjectAccountLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProjectAccountLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProjectAccountLookupTableDto {
    totalCount: number;
    items: ProjectAccountLookupTableDto[] | undefined;
}

export class ProjectTeamLookupTableDto implements IProjectTeamLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProjectTeamLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ProjectTeamLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTeamLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IProjectTeamLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfProjectTeamLookupTableDto implements IPagedResultDtoOfProjectTeamLookupTableDto {
    totalCount!: number;
    items!: ProjectTeamLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProjectTeamLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProjectTeamLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProjectTeamLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProjectTeamLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProjectTeamLookupTableDto {
    totalCount: number;
    items: ProjectTeamLookupTableDto[] | undefined;
}


export class PagedResultDtoOfProjectSysStatusLookupTableDto implements IPagedResultDtoOfProjectSysStatusLookupTableDto {
    totalCount!: number;
    items!: ProjectSysStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProjectSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProjectSysStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProjectSysStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProjectSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProjectSysStatusLookupTableDto {
    totalCount: number;
    items: ProjectSysStatusLookupTableDto[] | undefined;
}

//#endregion Project

//#region Project Instruction
@Injectable()
export class ProjectInstructionsCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxInstructionNoFilter (optional) 
     * @param minInstructionNoFilter (optional) 
     * @param instructionsFilter (optional) 
     * @param remarksFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param projectNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxInstructionNoFilter: number | undefined, minInstructionNoFilter: number | undefined, instructionsFilter: string | undefined, remarksFilter: string | undefined, isActiveFilter: number | undefined, projectNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetProjectInstructionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInstructions/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxInstructionNoFilter === null)
            throw new Error("The parameter 'maxInstructionNoFilter' cannot be null.");
        else if (maxInstructionNoFilter !== undefined)
            url_ += "MaxInstructionNoFilter=" + encodeURIComponent("" + maxInstructionNoFilter) + "&"; 
        if (minInstructionNoFilter === null)
            throw new Error("The parameter 'minInstructionNoFilter' cannot be null.");
        else if (minInstructionNoFilter !== undefined)
            url_ += "MinInstructionNoFilter=" + encodeURIComponent("" + minInstructionNoFilter) + "&"; 
        if (instructionsFilter === null)
            throw new Error("The parameter 'instructionsFilter' cannot be null.");
        else if (instructionsFilter !== undefined)
            url_ += "InstructionsFilter=" + encodeURIComponent("" + instructionsFilter) + "&"; 
        if (remarksFilter === null)
            throw new Error("The parameter 'remarksFilter' cannot be null.");
        else if (remarksFilter !== undefined)
            url_ += "RemarksFilter=" + encodeURIComponent("" + remarksFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (projectNameFilter === null)
            throw new Error("The parameter 'projectNameFilter' cannot be null.");
        else if (projectNameFilter !== undefined)
            url_ += "ProjectNameFilter=" + encodeURIComponent("" + projectNameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetProjectInstructionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetProjectInstructionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetProjectInstructionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetProjectInstructionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetProjectInstructionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProjectInstructionForView(id: number | undefined): Observable<GetProjectInstructionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInstructions/GetProjectInstructionForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectInstructionForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectInstructionForView(<any>response_);
                } catch (e) {
                    return <Observable<GetProjectInstructionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProjectInstructionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectInstructionForView(response: HttpResponseBase): Observable<GetProjectInstructionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProjectInstructionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProjectInstructionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProjectInstructionForEdit(id: number | undefined): Observable<GetProjectInstructionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInstructions/GetProjectInstructionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectInstructionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectInstructionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetProjectInstructionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProjectInstructionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectInstructionForEdit(response: HttpResponseBase): Observable<GetProjectInstructionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProjectInstructionForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProjectInstructionForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditProjectInstructionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInstructions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInstructions/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxInstructionNoFilter (optional) 
     * @param minInstructionNoFilter (optional) 
     * @param instructionsFilter (optional) 
     * @param remarksFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param projectNameFilter (optional) 
     * @return Success
     */
    getProjectInstructionsToExcel(filter: string | undefined, maxInstructionNoFilter: number | undefined, minInstructionNoFilter: number | undefined, instructionsFilter: string | undefined, remarksFilter: string | undefined, isActiveFilter: number | undefined, projectNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInstructions/GetProjectInstructionsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxInstructionNoFilter === null)
            throw new Error("The parameter 'maxInstructionNoFilter' cannot be null.");
        else if (maxInstructionNoFilter !== undefined)
            url_ += "MaxInstructionNoFilter=" + encodeURIComponent("" + maxInstructionNoFilter) + "&"; 
        if (minInstructionNoFilter === null)
            throw new Error("The parameter 'minInstructionNoFilter' cannot be null.");
        else if (minInstructionNoFilter !== undefined)
            url_ += "MinInstructionNoFilter=" + encodeURIComponent("" + minInstructionNoFilter) + "&"; 
        if (instructionsFilter === null)
            throw new Error("The parameter 'instructionsFilter' cannot be null.");
        else if (instructionsFilter !== undefined)
            url_ += "InstructionsFilter=" + encodeURIComponent("" + instructionsFilter) + "&"; 
        if (remarksFilter === null)
            throw new Error("The parameter 'remarksFilter' cannot be null.");
        else if (remarksFilter !== undefined)
            url_ += "RemarksFilter=" + encodeURIComponent("" + remarksFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (projectNameFilter === null)
            throw new Error("The parameter 'projectNameFilter' cannot be null.");
        else if (projectNameFilter !== undefined)
            url_ += "ProjectNameFilter=" + encodeURIComponent("" + projectNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectInstructionsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectInstructionsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectInstructionsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProjectForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProjectInstructionProjectLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInstructions/GetAllProjectForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjectForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjectForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProjectInstructionProjectLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProjectInstructionProjectLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProjectForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProjectInstructionProjectLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProjectInstructionProjectLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProjectInstructionProjectLookupTableDto>(<any>null);
    }
}


export class ProjectInstructionDto implements IProjectInstructionDto {
    instructionNo!: number;
    instructions!: string | undefined;
    remarks!: string | undefined;
    isActive!: boolean;
    projectId!: number | undefined;
    id!: number;

    constructor(data?: IProjectInstructionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.instructionNo = data["instructionNo"];
            this.instructions = data["instructions"];
            this.remarks = data["remarks"];
            this.isActive = data["isActive"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProjectInstructionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectInstructionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["instructionNo"] = this.instructionNo;
        data["instructions"] = this.instructions;
        data["remarks"] = this.remarks;
        data["isActive"] = this.isActive;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProjectInstructionDto {
    instructionNo: number;
    instructions: string | undefined;
    remarks: string | undefined;
    isActive: boolean;
    projectId: number | undefined;
    id: number;
}

export class GetProjectInstructionForViewDto implements IGetProjectInstructionForViewDto {
    projectInstruction!: ProjectInstructionDto;
    projectName!: string | undefined;

    constructor(data?: IGetProjectInstructionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectInstruction = data["projectInstruction"] ? ProjectInstructionDto.fromJS(data["projectInstruction"]) : <any>undefined;
            this.projectName = data["projectName"];
        }
    }

    static fromJS(data: any): GetProjectInstructionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProjectInstructionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectInstruction"] = this.projectInstruction ? this.projectInstruction.toJSON() : <any>undefined;
        data["projectName"] = this.projectName;
        return data; 
    }
}

export interface IGetProjectInstructionForViewDto {
    projectInstruction: ProjectInstructionDto;
    projectName: string | undefined;
}

export class PagedResultDtoOfGetProjectInstructionForViewDto implements IPagedResultDtoOfGetProjectInstructionForViewDto {
    totalCount!: number;
    items!: GetProjectInstructionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetProjectInstructionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetProjectInstructionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetProjectInstructionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetProjectInstructionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetProjectInstructionForViewDto {
    totalCount: number;
    items: GetProjectInstructionForViewDto[] | undefined;
}

export class CreateOrEditProjectInstructionDto implements ICreateOrEditProjectInstructionDto {
    instructionNo!: number;
    instructions!: string | undefined;
    remarks!: string | undefined;
    isActive!: boolean;
    projectId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditProjectInstructionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.instructionNo = data["instructionNo"];
            this.instructions = data["instructions"];
            this.remarks = data["remarks"];
            this.isActive = data["isActive"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditProjectInstructionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditProjectInstructionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["instructionNo"] = this.instructionNo;
        data["instructions"] = this.instructions;
        data["remarks"] = this.remarks;
        data["isActive"] = this.isActive;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditProjectInstructionDto {
    instructionNo: number;
    instructions: string | undefined;
    remarks: string | undefined;
    isActive: boolean;
    projectId: number | undefined;
    id: number | undefined;
}

export class GetProjectInstructionForEditOutput implements IGetProjectInstructionForEditOutput {
    projectInstruction!: CreateOrEditProjectInstructionDto;
    projectName!: string | undefined;

    constructor(data?: IGetProjectInstructionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectInstruction = data["projectInstruction"] ? CreateOrEditProjectInstructionDto.fromJS(data["projectInstruction"]) : <any>undefined;
            this.projectName = data["projectName"];
        }
    }

    static fromJS(data: any): GetProjectInstructionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProjectInstructionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectInstruction"] = this.projectInstruction ? this.projectInstruction.toJSON() : <any>undefined;
        data["projectName"] = this.projectName;
        return data; 
    }
}

export interface IGetProjectInstructionForEditOutput {
    projectInstruction: CreateOrEditProjectInstructionDto;
    projectName: string | undefined;
}

export class ProjectInstructionProjectLookupTableDto implements IProjectInstructionProjectLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProjectInstructionProjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ProjectInstructionProjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectInstructionProjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IProjectInstructionProjectLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfProjectInstructionProjectLookupTableDto implements IPagedResultDtoOfProjectInstructionProjectLookupTableDto {
    totalCount!: number;
    items!: ProjectInstructionProjectLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProjectInstructionProjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProjectInstructionProjectLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProjectInstructionProjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProjectInstructionProjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProjectInstructionProjectLookupTableDto {
    totalCount: number;
    items: ProjectInstructionProjectLookupTableDto[] | undefined;
}
//#endregion

//#region ProductCategories
@Injectable()
export class ProductCategoriesCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    
    /**
     * @param filter (optional) 
     * @param productNameFilter (optional) 
     * @param categoryNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, productNameFilter: string | undefined, categoryNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetProductCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&"; 
        if (categoryNameFilter === null)
            throw new Error("The parameter 'categoryNameFilter' cannot be null.");
        else if (categoryNameFilter !== undefined)
            url_ += "CategoryNameFilter=" + encodeURIComponent("" + categoryNameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetProductCategoryForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetProductCategoryForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetProductCategoryForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetProductCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetProductCategoryForViewDto>(<any>null);
    }

    /**
     * @return Success
     */
    getProductCategory(
        productId: number | undefined,
        categoryId: number | undefined
    ): Observable<PagedResultDtoOfGetProductCategoryForViewDto> {
        let url_ =
            this.baseUrl +
            "/api/services/app/ProductCategories/GetProductCategory?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";

        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";

        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetProductCategory(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetProductCategory(
                                <any>response_
                            );
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfGetProductCategoryForViewDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<
                                PagedResultDtoOfGetProductCategoryForViewDto
                            >
                        >(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetProductCategory(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfGetProductCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfGetProductCategoryForViewDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfGetProductCategoryForViewDto>(
            <any>null
        );
    }

    /**
     * @return Success
     */
    getProductCategoriesNameValue(
        productId: number | undefined
    ): Observable<NameValueProductOfString[]> {
        let url_ =
            this.baseUrl +
            "/api/services/app/ProductCategories/GetProductCategoriesNameValue?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";

        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetProductCategories(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetProductCategories(
                                <any>response_
                            );
                        } catch (e) {
                            return <Observable<NameValueProductOfString[]>>(
                                (<any>_observableThrow(e))
                            );
                        }
                    } else
                        return <Observable<NameValueProductOfString[]>>(
                            (<any>_observableThrow(response_))
                        );
                })
            );
    }

    protected processGetProductCategories(
        response: HttpResponseBase
    ): Observable<NameValueProductOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200)
                            result200!.push(
                                NameValueProductOfString.fromJS(item)
                            );
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<NameValueProductOfString[]>(<any>null);
    }

    /**
     * @ProductId (numbers)
     * @param body (optional)
     * @return Success
     */
    sendAndGetSelectedCategories(
        productId: number | undefined,
        body: NameValueProductOfString[] | undefined
    ): Observable<NameValueProductOfString[]> {
        let url_ =
            this.baseUrl +
            "/api/services/app/ProductCategories/sendAndGetSelectedCategories";
        url_ = url_.replace(/[?&]$/, "");

        for (let i = 0; i < body.length; i++) {
            body[i].productId = productId.toString();
        }
        var test = body;
        const content_ = JSON.stringify(test);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                Accept: "text/plain"
            })
        };

        return this.http
            .request("post", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateProductCategories(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateProductCategories(
                                <any>response_
                            );
                        } catch (e) {
                            return <Observable<NameValueProductOfString[]>>(
                                (<any>_observableThrow(e))
                            );
                        }
                    } else
                        return <Observable<NameValueProductOfString[]>>(
                            (<any>_observableThrow(response_))
                        );
                })
            );
    }

    protected processUpdateProductCategories(
        response: HttpResponseBase
    ): Observable<NameValueProductOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200)
                            result200!.push(
                                NameValueProductOfString.fromJS(item)
                            );
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<NameValueProductOfString[]>(<any>null);
    }

    
    protected processSendAndGetSelectedCategories(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductCategoryForView(id: number | undefined): Observable<GetProductCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/GetProductCategoryForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoryForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoryForView(<any>response_);
                } catch (e) {
                    return <Observable<GetProductCategoryForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProductCategoryForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductCategoryForView(response: HttpResponseBase): Observable<GetProductCategoryForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProductCategoryForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductCategoryForEdit(id: number | undefined): Observable<GetProductCategoryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/GetProductCategoryForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoryForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetProductCategoryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProductCategoryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductCategoryForEdit(response: HttpResponseBase): Observable<GetProductCategoryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductCategoryForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProductCategoryForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditProductCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProductForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductCategoryProductLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/GetAllProductForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductCategoryProductLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductCategoryProductLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductCategoryProductLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductCategoryProductLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductCategoryProductLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductCategoryCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/GetAllCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategoryForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductCategoryCategoryLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductCategoryCategoryLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductCategoryCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductCategoryCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductCategoryCategoryLookupTableDto>(<any>null);
    }
}

export class GetProductCategoryForViewDto
    implements IGetProductCategoryForViewDto {
    productCategory!: ProductCategoryDto;
    productName!: string | undefined;
    categoryName!: string | undefined;

    constructor(data?: IGetProductCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productCategory = data["productCategory"]
                ? ProductCategoryDto.fromJS(data["productCategory"])
                : <any>undefined;
            this.productName = data["productName"];
            this.categoryName = data["categoryName"];
        }
    }

    static fromJS(data: any): GetProductCategoryForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new GetProductCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["productCategory"] = this.productCategory
            ? this.productCategory.toJSON()
            : <any>undefined;
        data["productName"] = this.productName;
        data["categoryName"] = this.categoryName;
        return data;
    }
}

export class ProductCategoryDto implements IProductCategoryDto {
    productId!: number | undefined;
    categoryId!: number | undefined;
    id!: number;

    constructor(data?: IProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productId = data["productId"];
            this.categoryId = data["categoryId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProductCategoryDto {
        data = typeof data === "object" ? data : {};
        let result = new ProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["productId"] = this.productId;
        data["categoryId"] = this.categoryId;
        data["id"] = this.id;
        return data;
    }
}

export interface IProductCategoryDto {
    productId: number | undefined;
    categoryId: number | undefined;
    id: number;
}

export interface IGetProductCategoryForViewDto {
    productCategory: ProductCategoryDto;
    productName: string | undefined;
    categoryName: string | undefined;
}

export class PagedResultDtoOfGetProductCategoryForViewDto
    implements IPagedResultDtoOfGetProductCategoryForViewDto {
    totalCount!: number;
    items!: GetProductCategoryForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetProductCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetProductCategoryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetProductCategoryForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfGetProductCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetProductCategoryForViewDto {
    totalCount: number;
    items: GetProductCategoryForViewDto[] | undefined;
}
export class NameValueProductOfString implements INameValueProductOfString {
    name!: string | undefined;
    value!: string | undefined;
    productId!: string | undefined;

    constructor(data?: INameValueProductOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
            this.productId = data["productId"];
        }
    }

    static fromJS(data: any): NameValueProductOfString {
        data = typeof data === "object" ? data : {};
        let result = new NameValueProductOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        data["productId"] = this.productId;
        return data;
    }
}

export interface INameValueProductOfString {
    name: string | undefined;
    value: string | undefined;
    productId: string | undefined;
}

@Injectable()
export class CategoriesCustomServiceByProductProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    GetCategoriesNameValue(): Observable<NameValueProductOfString[]> {
        let url_ =
            this.baseUrl +
            "/api/services/app/Categories/GetCategoriesNameValue";

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCategories(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCategories(<any>response_);
                        } catch (e) {
                            return <Observable<NameValueProductOfString[]>>(
                                (<any>_observableThrow(e))
                            );
                        }
                    } else
                        return <Observable<NameValueProductOfString[]>>(
                            (<any>_observableThrow(response_))
                        );
                })
            );
    }

    protected processGetCategories(
        response: HttpResponseBase
    ): Observable<NameValueProductOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200)
                            result200!.push(
                                NameValueProductOfString.fromJS(item)
                            );
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<NameValueProductOfString[]>(<any>null);
    }
}


export interface IProductCategoryDto {
    productId: number | undefined;
    categoryId: number | undefined;
    id: number;
}

export interface IGetProductCategoryForViewDto {
    productCategory: ProductCategoryDto;
    productName: string | undefined;
    categoryName: string | undefined;
}


export interface IPagedResultDtoOfGetProductCategoryForViewDto {
    totalCount: number;
    items: GetProductCategoryForViewDto[] | undefined;
}

export class NameValueProduct implements INameValueProduct {
    name!: string | undefined;
    value!: string | undefined;
    productId!: string | undefined;

    constructor(data?: INameValueProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
            this.productId = data["productId"];
        }
    }

    static fromJS(data: any): NameValueProduct {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        data["productId"] = this.productId;
        return data; 
    }
}

export interface INameValueProduct {
    name: string | undefined;
    value: string | undefined;
    productId: string | undefined;
}

export class CreateOrEditProductCategoryDto implements ICreateOrEditProductCategoryDto {
    productId!: number | undefined;
    categoryId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productId = data["productId"];
            this.categoryId = data["categoryId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["categoryId"] = this.categoryId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditProductCategoryDto {
    productId: number | undefined;
    categoryId: number | undefined;
    id: number | undefined;
}

export class GetProductCategoryForEditOutput implements IGetProductCategoryForEditOutput {
    productCategory!: CreateOrEditProductCategoryDto;
    productName!: string | undefined;
    categoryName!: string | undefined;

    constructor(data?: IGetProductCategoryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productCategory = data["productCategory"] ? CreateOrEditProductCategoryDto.fromJS(data["productCategory"]) : <any>undefined;
            this.productName = data["productName"];
            this.categoryName = data["categoryName"];
        }
    }

    static fromJS(data: any): GetProductCategoryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductCategoryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCategory"] = this.productCategory ? this.productCategory.toJSON() : <any>undefined;
        data["productName"] = this.productName;
        data["categoryName"] = this.categoryName;
        return data; 
    }
}

export interface IGetProductCategoryForEditOutput {
    productCategory: CreateOrEditProductCategoryDto;
    productName: string | undefined;
    categoryName: string | undefined;
}

export class ProductCategoryProductLookupTableDto implements IProductCategoryProductLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductCategoryProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ProductCategoryProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IProductCategoryProductLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfProductCategoryProductLookupTableDto implements IPagedResultDtoOfProductCategoryProductLookupTableDto {
    totalCount!: number;
    items!: ProductCategoryProductLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductCategoryProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProductCategoryProductLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductCategoryProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductCategoryProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProductCategoryProductLookupTableDto {
    totalCount: number;
    items: ProductCategoryProductLookupTableDto[] | undefined;
}

export class ProductCategoryCategoryLookupTableDto implements IProductCategoryCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductCategoryCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ProductCategoryCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IProductCategoryCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfProductCategoryCategoryLookupTableDto implements IPagedResultDtoOfProductCategoryCategoryLookupTableDto {
    totalCount!: number;
    items!: ProductCategoryCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductCategoryCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProductCategoryCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductCategoryCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductCategoryCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProductCategoryCategoryLookupTableDto {
    totalCount: number;
    items: ProductCategoryCategoryLookupTableDto[] | undefined;
}

//#endregion

//#region ProductPrices
@Injectable()
export class ProductPricesCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxPriceFilter (optional) 
     * @param minPriceFilter (optional) 
     * @param maxvalidityFilter (optional) 
     * @param minvalidityFilter (optional) 
     * @param productNameFilter (optional) 
     * @param productIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxPriceFilter: number | undefined, minPriceFilter: number | undefined, maxvalidityFilter: moment.Moment | undefined, minvalidityFilter: moment.Moment | undefined, productNameFilter: string | undefined, productIdFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetProductPriceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductPrices/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxPriceFilter === null)
            throw new Error("The parameter 'maxPriceFilter' cannot be null.");
        else if (maxPriceFilter !== undefined)
            url_ += "MaxPriceFilter=" + encodeURIComponent("" + maxPriceFilter) + "&"; 
        if (minPriceFilter === null)
            throw new Error("The parameter 'minPriceFilter' cannot be null.");
        else if (minPriceFilter !== undefined)
            url_ += "MinPriceFilter=" + encodeURIComponent("" + minPriceFilter) + "&"; 
        if (maxvalidityFilter === null)
            throw new Error("The parameter 'maxvalidityFilter' cannot be null.");
        else if (maxvalidityFilter !== undefined)
            url_ += "MaxvalidityFilter=" + encodeURIComponent(maxvalidityFilter ? "" + maxvalidityFilter.toJSON() : "") + "&"; 
        if (minvalidityFilter === null)
            throw new Error("The parameter 'minvalidityFilter' cannot be null.");
        else if (minvalidityFilter !== undefined)
            url_ += "MinvalidityFilter=" + encodeURIComponent(minvalidityFilter ? "" + minvalidityFilter.toJSON() : "") + "&"; 
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&"; 
        if (productIdFilter === null)
            throw new Error("The parameter 'productIdFilter' cannot be null.");
        else if (productIdFilter !== undefined)
            url_ += "ProductIdFilter=" + encodeURIComponent("" + productIdFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetProductPriceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetProductPriceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetProductPriceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetProductPriceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetProductPriceForViewDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param maxPriceFilter (optional)
     * @param minPriceFilter (optional)
     * @param maxvalidityFilter (optional)
     * @param minvalidityFilter (optional)
     * @param productNameFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getByProductId(
        productIDFilter: number | undefined,
        sorting: string | undefined,
        skipCount: number | undefined,
        maxResultCount: number | undefined
    ): Observable<PagedResultDtoOfGetProductPriceForViewDto> {
        let url_ =
            this.baseUrl + "/api/services/app/ProductPrices/GetByProductId?";
        if (productIDFilter === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productIDFilter !== undefined)
            url_ +=
                "productIDFilter=" +
                encodeURIComponent("" + productIDFilter) +
                "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ +=
                "MaxResultCount=" +
                encodeURIComponent("" + maxResultCount) +
                "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetByProductId(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetByProductId(<any>response_);
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfGetProductPriceForViewDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<
                                PagedResultDtoOfGetProductPriceForViewDto
                            >
                        >(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetByProductId(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfGetProductPriceForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfGetProductPriceForViewDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfGetProductPriceForViewDto>(
            <any>null
        );
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductPriceForView(id: number | undefined): Observable<GetProductPriceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductPrices/GetProductPriceForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductPriceForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductPriceForView(<any>response_);
                } catch (e) {
                    return <Observable<GetProductPriceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProductPriceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductPriceForView(response: HttpResponseBase): Observable<GetProductPriceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductPriceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProductPriceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductPriceForEdit(id: number | undefined): Observable<GetProductPriceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ProductPrices/GetProductPriceForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductPriceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductPriceForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetProductPriceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProductPriceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductPriceForEdit(response: HttpResponseBase): Observable<GetProductPriceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductPriceForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProductPriceForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditProductPriceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductPrices/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductPrices/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxPriceFilter (optional) 
     * @param minPriceFilter (optional) 
     * @param maxvalidityFilter (optional) 
     * @param minvalidityFilter (optional) 
     * @param productNameFilter (optional) 
     * @return Success
     */
    getProductPricesToExcel(filter: string | undefined, maxPriceFilter: number | undefined, minPriceFilter: number | undefined, maxvalidityFilter: moment.Moment | undefined, minvalidityFilter: moment.Moment | undefined, productNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductPrices/GetProductPricesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxPriceFilter === null)
            throw new Error("The parameter 'maxPriceFilter' cannot be null.");
        else if (maxPriceFilter !== undefined)
            url_ += "MaxPriceFilter=" + encodeURIComponent("" + maxPriceFilter) + "&"; 
        if (minPriceFilter === null)
            throw new Error("The parameter 'minPriceFilter' cannot be null.");
        else if (minPriceFilter !== undefined)
            url_ += "MinPriceFilter=" + encodeURIComponent("" + minPriceFilter) + "&"; 
        if (maxvalidityFilter === null)
            throw new Error("The parameter 'maxvalidityFilter' cannot be null.");
        else if (maxvalidityFilter !== undefined)
            url_ += "MaxvalidityFilter=" + encodeURIComponent(maxvalidityFilter ? "" + maxvalidityFilter.toJSON() : "") + "&"; 
        if (minvalidityFilter === null)
            throw new Error("The parameter 'minvalidityFilter' cannot be null.");
        else if (minvalidityFilter !== undefined)
            url_ += "MinvalidityFilter=" + encodeURIComponent(minvalidityFilter ? "" + minvalidityFilter.toJSON() : "") + "&"; 
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductPricesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductPricesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductPricesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProductForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductPriceProductLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductPrices/GetAllProductForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductPriceProductLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductPriceProductLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductPriceProductLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductPriceProductLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductPriceProductLookupTableDto>(<any>null);
    }
}

export class PagedResultDtoOfGetProductPriceForViewDto
    implements IPagedResultDtoOfGetProductPriceForViewDto {
    totalCount!: number;
    items!: GetProductPriceForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetProductPriceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetProductPriceForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetProductPriceForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfGetProductPriceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetProductPriceForViewDto {
    totalCount: number;
    items: GetProductPriceForViewDto[] | undefined;
}

export class GetProductPriceForViewDto implements IGetProductPriceForViewDto {
    productPrice!: ProductPriceDto;
    productName!: string | undefined;

    constructor(data?: IGetProductPriceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productPrice = data["productPrice"]
                ? ProductPriceDto.fromJS(data["productPrice"])
                : <any>undefined;
            this.productName = data["productName"];
        }
    }

    static fromJS(data: any): GetProductPriceForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new GetProductPriceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["productPrice"] = this.productPrice
            ? this.productPrice.toJSON()
            : <any>undefined;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IGetProductPriceForViewDto {
    productPrice: ProductPriceDto;
    productName: string | undefined;
}

export class ProductPriceDto implements IProductPriceDto {
    price!: number;
    validity!: moment.Moment;
    productId!: number | undefined;
    id!: number;

    constructor(data?: IProductPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.price = data["price"];
            this.validity = data["validity"]
                ? moment(data["validity"].toString())
                : <any>undefined;
            this.productId = data["productId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProductPriceDto {
        data = typeof data === "object" ? data : {};
        let result = new ProductPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["price"] = this.price;
        data["validity"] = this.validity
            ? this.validity.toISOString()
            : <any>undefined;
        data["productId"] = this.productId;
        data["id"] = this.id;
        return data;
    }
}

export interface IProductPriceDto {
    price: number;
    validity: moment.Moment;
    productId: number | undefined;
    id: number;
}

export interface IProductPriceDto {
    price: number;
    validity: moment.Moment;
    productId: number | undefined;
    id: number;
}


export interface IGetProductPriceForViewDto {
    productPrice: ProductPriceDto;
    productName: string | undefined;
}


export interface IPagedResultDtoOfGetProductPriceForViewDto {
    totalCount: number;
    items: GetProductPriceForViewDto[] | undefined;
}

export class CreateOrEditProductPriceDto implements ICreateOrEditProductPriceDto {
    price!: number;
    validity!: moment.Moment;
    productId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditProductPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.price = data["price"];
            this.validity = data["validity"] ? moment(data["validity"].toString()) : <any>undefined;
            this.productId = data["productId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditProductPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditProductPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["price"] = this.price;
        data["validity"] = this.validity ? this.validity.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditProductPriceDto {
    price: number;
    validity: moment.Moment;
    productId: number | undefined;
    id: number | undefined;
}

export class GetProductPriceForEditOutput implements IGetProductPriceForEditOutput {
    productPrice!: CreateOrEditProductPriceDto;
    productName!: string | undefined;

    constructor(data?: IGetProductPriceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productPrice = data["productPrice"] ? CreateOrEditProductPriceDto.fromJS(data["productPrice"]) : <any>undefined;
            this.productName = data["productName"];
        }
    }

    static fromJS(data: any): GetProductPriceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductPriceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productPrice"] = this.productPrice ? this.productPrice.toJSON() : <any>undefined;
        data["productName"] = this.productName;
        return data; 
    }
}

export interface IGetProductPriceForEditOutput {
    productPrice: CreateOrEditProductPriceDto;
    productName: string | undefined;
}

export class ProductPriceProductLookupTableDto implements IProductPriceProductLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductPriceProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ProductPriceProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPriceProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IProductPriceProductLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfProductPriceProductLookupTableDto implements IPagedResultDtoOfProductPriceProductLookupTableDto {
    totalCount!: number;
    items!: ProductPriceProductLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductPriceProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProductPriceProductLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductPriceProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductPriceProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProductPriceProductLookupTableDto {
    totalCount: number;
    items: ProductPriceProductLookupTableDto[] | undefined;
}

//#endregion

//#region ReferenceType
@Injectable()
export class ReferenceTypesCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param referenceTypeCodeFilter (optional) 
     * @param referenceTypeGroupFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, referenceTypeCodeFilter: string | undefined, referenceTypeGroupFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetReferenceTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ReferenceTypes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (referenceTypeCodeFilter === null)
            throw new Error("The parameter 'referenceTypeCodeFilter' cannot be null.");
        else if (referenceTypeCodeFilter !== undefined)
            url_ += "ReferenceTypeCodeFilter=" + encodeURIComponent("" + referenceTypeCodeFilter) + "&"; 
        if (referenceTypeGroupFilter === null)
            throw new Error("The parameter 'referenceTypeGroupFilter' cannot be null.");
        else if (referenceTypeGroupFilter !== undefined)
            url_ += "ReferenceTypeGroupFilter=" + encodeURIComponent("" + referenceTypeGroupFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetReferenceTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetReferenceTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetReferenceTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetReferenceTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetReferenceTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getReferenceTypeForView(id: number | undefined): Observable<GetReferenceTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ReferenceTypes/GetReferenceTypeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetReferenceTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReferenceTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeForView(response: HttpResponseBase): Observable<GetReferenceTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetReferenceTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReferenceTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getReferenceTypeForEdit(id: number | undefined): Observable<GetReferenceTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ReferenceTypes/GetReferenceTypeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetReferenceTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReferenceTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeForEdit(response: HttpResponseBase): Observable<GetReferenceTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetReferenceTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReferenceTypeForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditReferenceTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReferenceTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReferenceTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param referenceTypeCodeFilter (optional) 
     * @param referenceTypeGroupFilter (optional) 
     * @return Success
     */
    getReferenceTypesToExcel(filter: string | undefined, nameFilter: string | undefined, referenceTypeCodeFilter: string | undefined, referenceTypeGroupFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ReferenceTypes/GetReferenceTypesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (referenceTypeCodeFilter === null)
            throw new Error("The parameter 'referenceTypeCodeFilter' cannot be null.");
        else if (referenceTypeCodeFilter !== undefined)
            url_ += "ReferenceTypeCodeFilter=" + encodeURIComponent("" + referenceTypeCodeFilter) + "&"; 
        if (referenceTypeGroupFilter === null)
            throw new Error("The parameter 'referenceTypeGroupFilter' cannot be null.");
        else if (referenceTypeGroupFilter !== undefined)
            url_ += "ReferenceTypeGroupFilter=" + encodeURIComponent("" + referenceTypeGroupFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}


export interface IPagedResultDtoOfProjectSysStatusLookupTableDto {
    totalCount: number;
    items: ProjectSysStatusLookupTableDto[] | undefined;
}

export class ReferenceTypeDto implements IReferenceTypeDto {
    name!: string | undefined;
    referenceTypeCode!: string | undefined;
    referenceTypeGroup!: string | undefined;
    id!: number;

    constructor(data?: IReferenceTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.referenceTypeCode = data["referenceTypeCode"];
            this.referenceTypeGroup = data["referenceTypeGroup"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ReferenceTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["referenceTypeCode"] = this.referenceTypeCode;
        data["referenceTypeGroup"] = this.referenceTypeGroup;
        data["id"] = this.id;
        return data; 
    }
}

export interface IReferenceTypeDto {
    name: string | undefined;
    referenceTypeCode: string | undefined;
    referenceTypeGroup: string | undefined;
    id: number;
}

export class GetReferenceTypeForViewDto implements IGetReferenceTypeForViewDto {
    referenceType!: ReferenceTypeDto;

    constructor(data?: IGetReferenceTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.referenceType = data["referenceType"] ? ReferenceTypeDto.fromJS(data["referenceType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetReferenceTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReferenceTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceType"] = this.referenceType ? this.referenceType.toJSON() : <any>undefined;
        return data; 
    }
}

export class ProjectSysStatusLookupTableDto implements IProjectSysStatusLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProjectSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ProjectSysStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IProjectSysStatusLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export interface IGetReferenceTypeForViewDto {
    referenceType: ReferenceTypeDto;
}

export class PagedResultDtoOfGetReferenceTypeForViewDto implements IPagedResultDtoOfGetReferenceTypeForViewDto {
    totalCount!: number;
    items!: GetReferenceTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetReferenceTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetReferenceTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetReferenceTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetReferenceTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetReferenceTypeForViewDto {
    totalCount: number;
    items: GetReferenceTypeForViewDto[] | undefined;
}

export class CreateOrEditReferenceTypeDto implements ICreateOrEditReferenceTypeDto {
    name!: string | undefined;
    referenceTypeCode!: string | undefined;
    referenceTypeGroup!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditReferenceTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.referenceTypeCode = data["referenceTypeCode"];
            this.referenceTypeGroup = data["referenceTypeGroup"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditReferenceTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditReferenceTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["referenceTypeCode"] = this.referenceTypeCode;
        data["referenceTypeGroup"] = this.referenceTypeGroup;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditReferenceTypeDto {
    name: string | undefined;
    referenceTypeCode: string | undefined;
    referenceTypeGroup: string | undefined;
    id: number | undefined;
}

export class GetReferenceTypeForEditOutput implements IGetReferenceTypeForEditOutput {
    referenceType!: CreateOrEditReferenceTypeDto;

    constructor(data?: IGetReferenceTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.referenceType = data["referenceType"] ? CreateOrEditReferenceTypeDto.fromJS(data["referenceType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetReferenceTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetReferenceTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceType"] = this.referenceType ? this.referenceType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetReferenceTypeForEditOutput {
    referenceType: CreateOrEditReferenceTypeDto;
}
//#endregion ReferenceType

//#region Services
@Injectable()
export class ServicesCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxDurationFilter (optional) 
     * @param minDurationFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param remarkFilter (optional) 
     * @param categoryNameFilter (optional) 
     * @param sysRefRefCodeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, maxDurationFilter: number | undefined, minDurationFilter: number | undefined, isApprovedFilter: number | undefined, isActiveFilter: number | undefined, remarkFilter: string | undefined, categoryNameFilter: string | undefined, sysRefRefCodeFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetServiceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Services/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxDurationFilter === null)
            throw new Error("The parameter 'maxDurationFilter' cannot be null.");
        else if (maxDurationFilter !== undefined)
            url_ += "MaxDurationFilter=" + encodeURIComponent("" + maxDurationFilter) + "&"; 
        if (minDurationFilter === null)
            throw new Error("The parameter 'minDurationFilter' cannot be null.");
        else if (minDurationFilter !== undefined)
            url_ += "MinDurationFilter=" + encodeURIComponent("" + minDurationFilter) + "&"; 
        if (isApprovedFilter === null)
            throw new Error("The parameter 'isApprovedFilter' cannot be null.");
        else if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (categoryNameFilter === null)
            throw new Error("The parameter 'categoryNameFilter' cannot be null.");
        else if (categoryNameFilter !== undefined)
            url_ += "CategoryNameFilter=" + encodeURIComponent("" + categoryNameFilter) + "&"; 
        if (sysRefRefCodeFilter === null)
            throw new Error("The parameter 'sysRefRefCodeFilter' cannot be null.");
        else if (sysRefRefCodeFilter !== undefined)
            url_ += "SysRefRefCodeFilter=" + encodeURIComponent("" + sysRefRefCodeFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetServiceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetServiceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetServiceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetServiceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetServiceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getServiceForView(id: number | undefined): Observable<GetServiceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Services/GetServiceForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServiceForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServiceForView(<any>response_);
                } catch (e) {
                    return <Observable<GetServiceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetServiceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetServiceForView(response: HttpResponseBase): Observable<GetServiceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetServiceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetServiceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getServiceForEdit(id: number | undefined): Observable<GetServiceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Services/GetServiceForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServiceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServiceForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetServiceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetServiceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetServiceForEdit(response: HttpResponseBase): Observable<GetServiceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetServiceForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetServiceForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditServiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Services/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Services/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxDurationFilter (optional) 
     * @param minDurationFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param remarkFilter (optional) 
     * @param categoryNameFilter (optional) 
     * @param sysRefRefCodeFilter (optional) 
     * @return Success
     */
    getServicesToExcel(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, maxDurationFilter: number | undefined, minDurationFilter: number | undefined, isApprovedFilter: number | undefined, isActiveFilter: number | undefined, remarkFilter: string | undefined, categoryNameFilter: string | undefined, sysRefRefCodeFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Services/GetServicesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxDurationFilter === null)
            throw new Error("The parameter 'maxDurationFilter' cannot be null.");
        else if (maxDurationFilter !== undefined)
            url_ += "MaxDurationFilter=" + encodeURIComponent("" + maxDurationFilter) + "&"; 
        if (minDurationFilter === null)
            throw new Error("The parameter 'minDurationFilter' cannot be null.");
        else if (minDurationFilter !== undefined)
            url_ += "MinDurationFilter=" + encodeURIComponent("" + minDurationFilter) + "&"; 
        if (isApprovedFilter === null)
            throw new Error("The parameter 'isApprovedFilter' cannot be null.");
        else if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (categoryNameFilter === null)
            throw new Error("The parameter 'categoryNameFilter' cannot be null.");
        else if (categoryNameFilter !== undefined)
            url_ += "CategoryNameFilter=" + encodeURIComponent("" + categoryNameFilter) + "&"; 
        if (sysRefRefCodeFilter === null)
            throw new Error("The parameter 'sysRefRefCodeFilter' cannot be null.");
        else if (sysRefRefCodeFilter !== undefined)
            url_ += "SysRefRefCodeFilter=" + encodeURIComponent("" + sysRefRefCodeFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServicesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServicesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetServicesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfServiceCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Services/GetAllCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategoryForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfServiceCategoryLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfServiceCategoryLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfServiceCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfServiceCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfServiceCategoryLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysRefForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfServiceSysRefLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Services/GetAllSysRefForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysRefForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysRefForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfServiceSysRefLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfServiceSysRefLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysRefForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfServiceSysRefLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfServiceSysRefLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfServiceSysRefLookupTableDto>(<any>null);
    }

    /**
     * @param refType (optional) 
     * @return Success
     */
    getSysRefByRefType(refType: string | undefined): Observable<PagedResultDtoOfServiceSysRefLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Services/GetSysRefByRefType?";
        if (refType === null)
            throw new Error("The parameter 'refType' cannot be null.");
        else if (refType !== undefined)
            url_ += "refType=" + encodeURIComponent("" + refType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSysRefByRefType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSysRefByRefType(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfServiceSysRefLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfServiceSysRefLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSysRefByRefType(response: HttpResponseBase): Observable<PagedResultDtoOfServiceSysRefLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfServiceSysRefLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfServiceSysRefLookupTableDto>(<any>null);
    }
}

export class ServiceDto implements IServiceDto {
    name!: string | undefined;
    description!: string | undefined;
    duration!: number;
    isApproved!: boolean;
    isActive!: boolean;
    remark!: string | undefined;
    categoryId!: number | undefined;
    sysRefId!: number | undefined;
    id!: number;

    constructor(data?: IServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.duration = data["duration"];
            this.isApproved = data["isApproved"];
            this.isActive = data["isActive"];
            this.remark = data["remark"];
            this.categoryId = data["categoryId"];
            this.sysRefId = data["sysRefId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["isApproved"] = this.isApproved;
        data["isActive"] = this.isActive;
        data["remark"] = this.remark;
        data["categoryId"] = this.categoryId;
        data["sysRefId"] = this.sysRefId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IServiceDto {
    name: string | undefined;
    description: string | undefined;
    duration: number;
    isApproved: boolean;
    isActive: boolean;
    remark: string | undefined;
    categoryId: number | undefined;
    sysRefId: number | undefined;
    id: number;
}

export class GetServiceForViewDto implements IGetServiceForViewDto {
    service!: ServiceDto;
    categoryName!: string | undefined;
    sysRefRefCode!: string | undefined;

    constructor(data?: IGetServiceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.service = data["service"] ? ServiceDto.fromJS(data["service"]) : <any>undefined;
            this.categoryName = data["categoryName"];
            this.sysRefRefCode = data["sysRefRefCode"];
        }
    }

    static fromJS(data: any): GetServiceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetServiceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["service"] = this.service ? this.service.toJSON() : <any>undefined;
        data["categoryName"] = this.categoryName;
        data["sysRefRefCode"] = this.sysRefRefCode;
        return data; 
    }
}

export interface IGetServiceForViewDto {
    service: ServiceDto;
    categoryName: string | undefined;
    sysRefRefCode: string | undefined;
}

export class PagedResultDtoOfGetServiceForViewDto implements IPagedResultDtoOfGetServiceForViewDto {
    totalCount!: number;
    items!: GetServiceForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetServiceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetServiceForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetServiceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetServiceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetServiceForViewDto {
    totalCount: number;
    items: GetServiceForViewDto[] | undefined;
}

export class CreateOrEditServiceDto implements ICreateOrEditServiceDto {
    name!: string | undefined;
    description!: string | undefined;
    duration!: number;
    isApproved!: boolean;
    isActive!: boolean;
    remark!: string | undefined;
    categoryId!: number | undefined;
    sysRefId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.duration = data["duration"];
            this.isApproved = data["isApproved"];
            this.isActive = data["isActive"];
            this.remark = data["remark"];
            this.categoryId = data["categoryId"];
            this.sysRefId = data["sysRefId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["isApproved"] = this.isApproved;
        data["isActive"] = this.isActive;
        data["remark"] = this.remark;
        data["categoryId"] = this.categoryId;
        data["sysRefId"] = this.sysRefId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditServiceDto {
    name: string | undefined;
    description: string | undefined;
    duration: number;
    isApproved: boolean;
    isActive: boolean;
    remark: string | undefined;
    categoryId: number | undefined;
    sysRefId: number | undefined;
    id: number | undefined;
}

export class GetServiceForEditOutput implements IGetServiceForEditOutput {
    service!: CreateOrEditServiceDto;
    categoryName!: string | undefined;
    sysRefRefCode!: string | undefined;

    constructor(data?: IGetServiceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.service = data["service"] ? CreateOrEditServiceDto.fromJS(data["service"]) : <any>undefined;
            this.categoryName = data["categoryName"];
            this.sysRefRefCode = data["sysRefRefCode"];
        }
    }

    static fromJS(data: any): GetServiceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetServiceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["service"] = this.service ? this.service.toJSON() : <any>undefined;
        data["categoryName"] = this.categoryName;
        data["sysRefRefCode"] = this.sysRefRefCode;
        return data; 
    }
}

export interface IGetServiceForEditOutput {
    service: CreateOrEditServiceDto;
    categoryName: string | undefined;
    sysRefRefCode: string | undefined;
}

export class ServiceCategoryLookupTableDto implements IServiceCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IServiceCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ServiceCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IServiceCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfServiceCategoryLookupTableDto implements IPagedResultDtoOfServiceCategoryLookupTableDto {
    totalCount!: number;
    items!: ServiceCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfServiceCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ServiceCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfServiceCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfServiceCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfServiceCategoryLookupTableDto {
    totalCount: number;
    items: ServiceCategoryLookupTableDto[] | undefined;
}

export class ServiceSysRefLookupTableDto implements IServiceSysRefLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IServiceSysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ServiceSysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceSysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IServiceSysRefLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfServiceSysRefLookupTableDto implements IPagedResultDtoOfServiceSysRefLookupTableDto {
    totalCount!: number;
    items!: ServiceSysRefLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfServiceSysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ServiceSysRefLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfServiceSysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfServiceSysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfServiceSysRefLookupTableDto {
    totalCount: number;
    items: ServiceSysRefLookupTableDto[] | undefined;
}

//#endregion

//#region ServiceCategories

@Injectable()
export class ServiceCategoriesCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param serviceNameFilter (optional) 
     * @param categoryNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, serviceNameFilter: string | undefined, categoryNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetServiceCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ServiceCategories/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (serviceNameFilter === null)
            throw new Error("The parameter 'serviceNameFilter' cannot be null.");
        else if (serviceNameFilter !== undefined)
            url_ += "ServiceNameFilter=" + encodeURIComponent("" + serviceNameFilter) + "&"; 
        if (categoryNameFilter === null)
            throw new Error("The parameter 'categoryNameFilter' cannot be null.");
        else if (categoryNameFilter !== undefined)
            url_ += "CategoryNameFilter=" + encodeURIComponent("" + categoryNameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetServiceCategoryForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetServiceCategoryForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetServiceCategoryForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetServiceCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetServiceCategoryForViewDto>(<any>null);
    }

    /**
     * @return Success
     */
    getServiceCategory(
        serviceId: number | undefined,
        categoryId: number | undefined
    ): Observable<PagedResultDtoOfGetServiceCategoryForViewDto> {
        let url_ =
            this.baseUrl +
            "/api/services/app/ServiceCategories/GetServiceCategory?";
        if (serviceId === null)
            throw new Error("The parameter 'serviceId' cannot be null.");
        else if (serviceId !== undefined)
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&";

        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";

        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetServiceCategory(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetServiceCategory(
                                <any>response_
                            );
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfGetServiceCategoryForViewDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<
                                PagedResultDtoOfGetServiceCategoryForViewDto
                            >
                        >(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetServiceCategory(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfGetServiceCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfGetServiceCategoryForViewDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfGetServiceCategoryForViewDto>(
            <any>null
        );
    }

    /**
     * @return Success
     */
    getServiceCategoriesNameValue(
        serviceId: number | undefined
    ): Observable<NameValueServiceOfString[]> {
        let url_ =
            this.baseUrl +
            "/api/services/app/ServiceCategories/GetServiceCategoriesNameValue?";
        if (serviceId === null)
            throw new Error("The parameter 'serviceId' cannot be null.");
        else if (serviceId !== undefined)
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&";

        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetServiceCategories(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetServiceCategories(
                                <any>response_
                            );
                        } catch (e) {
                            return <Observable<NameValueServiceOfString[]>>(
                                (<any>_observableThrow(e))
                            );
                        }
                    } else
                        return <Observable<NameValueServiceOfString[]>>(
                            (<any>_observableThrow(response_))
                        );
                })
            );
    }

    protected processGetServiceCategories(
        response: HttpResponseBase
    ): Observable<NameValueServiceOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200)
                            result200!.push(
                                NameValueServiceOfString.fromJS(item)
                            );
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<NameValueServiceOfString[]>(<any>null);
    }

    /**
     * @ServiceId (numbers)
     * @param body (optional)
     * @return Success
     */
    sendAndGetSelectedCategories(
        serviceId: number | undefined,
        body: NameValueServiceOfString[] | undefined
    ): Observable<NameValueServiceOfString[]> {
        let url_ =
            this.baseUrl +
            "/api/services/app/ServiceCategories/sendAndGetSelectedCategories";
        url_ = url_.replace(/[?&]$/, "");

        for (let i = 0; i < body.length; i++) {
            body[i].serviceId = serviceId.toString();
        }
        var test = body;
        const content_ = JSON.stringify(test);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                Accept: "text/plain"
            })
        };

        return this.http
            .request("post", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateServiceCategories(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateServiceCategories(
                                <any>response_
                            );
                        } catch (e) {
                            return <Observable<NameValueServiceOfString[]>>(
                                (<any>_observableThrow(e))
                            );
                        }
                    } else
                        return <Observable<NameValueServiceOfString[]>>(
                            (<any>_observableThrow(response_))
                        );
                })
            );
    }

    protected processUpdateServiceCategories(
        response: HttpResponseBase
    ): Observable<NameValueServiceOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200)
                            result200!.push(
                                NameValueServiceOfString.fromJS(item)
                            );
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<NameValueServiceOfString[]>(<any>null);
    }

        protected processGetServiceCategoriesNameValue(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    protected processSendAndGetSelectedCategories(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getServiceCategoryForView(id: number | undefined): Observable<GetServiceCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ServiceCategories/GetServiceCategoryForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServiceCategoryForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServiceCategoryForView(<any>response_);
                } catch (e) {
                    return <Observable<GetServiceCategoryForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetServiceCategoryForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetServiceCategoryForView(response: HttpResponseBase): Observable<GetServiceCategoryForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetServiceCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetServiceCategoryForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getServiceCategoryForEdit(id: number | undefined): Observable<GetServiceCategoryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ServiceCategories/GetServiceCategoryForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServiceCategoryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServiceCategoryForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetServiceCategoryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetServiceCategoryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetServiceCategoryForEdit(response: HttpResponseBase): Observable<GetServiceCategoryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetServiceCategoryForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetServiceCategoryForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditServiceCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServiceCategories/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServiceCategories/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param serviceNameFilter (optional) 
     * @param categoryNameFilter (optional) 
     * @return Success
     */
    getServiceCategoriesToExcel(filter: string | undefined, serviceNameFilter: string | undefined, categoryNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ServiceCategories/GetServiceCategoriesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (serviceNameFilter === null)
            throw new Error("The parameter 'serviceNameFilter' cannot be null.");
        else if (serviceNameFilter !== undefined)
            url_ += "ServiceNameFilter=" + encodeURIComponent("" + serviceNameFilter) + "&"; 
        if (categoryNameFilter === null)
            throw new Error("The parameter 'categoryNameFilter' cannot be null.");
        else if (categoryNameFilter !== undefined)
            url_ += "CategoryNameFilter=" + encodeURIComponent("" + categoryNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServiceCategoriesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServiceCategoriesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetServiceCategoriesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllServiceForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfServiceCategoryServiceLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ServiceCategories/GetAllServiceForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllServiceForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllServiceForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfServiceCategoryServiceLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfServiceCategoryServiceLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllServiceForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfServiceCategoryServiceLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfServiceCategoryServiceLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfServiceCategoryServiceLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfServiceCategoryCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ServiceCategories/GetAllCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategoryForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfServiceCategoryCategoryLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfServiceCategoryCategoryLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfServiceCategoryCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfServiceCategoryCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfServiceCategoryCategoryLookupTableDto>(<any>null);
    }
}

export class NameValueService implements INameValueService {
    name!: string | undefined;
    value!: string | undefined;
    serviceId!: string | undefined;

    constructor(data?: INameValueService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
            this.serviceId = data["serviceId"];
        }
    }

    static fromJS(data: any): NameValueService {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueService();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        data["serviceId"] = this.serviceId;
        return data; 
    }
}

export interface INameValueService {
    name: string | undefined;
    value: string | undefined;
    serviceId: string | undefined;
}

export class CreateOrEditServiceCategoryDto implements ICreateOrEditServiceCategoryDto {
    serviceId!: number | undefined;
    categoryId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditServiceCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceId = data["serviceId"];
            this.categoryId = data["categoryId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditServiceCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditServiceCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceId"] = this.serviceId;
        data["categoryId"] = this.categoryId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditServiceCategoryDto {
    serviceId: number | undefined;
    categoryId: number | undefined;
    id: number | undefined;
}

export class GetServiceCategoryForEditOutput implements IGetServiceCategoryForEditOutput {
    serviceCategory!: CreateOrEditServiceCategoryDto;
    serviceName!: string | undefined;
    categoryName!: string | undefined;

    constructor(data?: IGetServiceCategoryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceCategory = data["serviceCategory"] ? CreateOrEditServiceCategoryDto.fromJS(data["serviceCategory"]) : <any>undefined;
            this.serviceName = data["serviceName"];
            this.categoryName = data["categoryName"];
        }
    }

    static fromJS(data: any): GetServiceCategoryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetServiceCategoryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceCategory"] = this.serviceCategory ? this.serviceCategory.toJSON() : <any>undefined;
        data["serviceName"] = this.serviceName;
        data["categoryName"] = this.categoryName;
        return data; 
    }
}

export interface IGetServiceCategoryForEditOutput {
    serviceCategory: CreateOrEditServiceCategoryDto;
    serviceName: string | undefined;
    categoryName: string | undefined;
}

export class ServiceCategoryServiceLookupTableDto implements IServiceCategoryServiceLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IServiceCategoryServiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ServiceCategoryServiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceCategoryServiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IServiceCategoryServiceLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfServiceCategoryServiceLookupTableDto implements IPagedResultDtoOfServiceCategoryServiceLookupTableDto {
    totalCount!: number;
    items!: ServiceCategoryServiceLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfServiceCategoryServiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ServiceCategoryServiceLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfServiceCategoryServiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfServiceCategoryServiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfServiceCategoryServiceLookupTableDto {
    totalCount: number;
    items: ServiceCategoryServiceLookupTableDto[] | undefined;
}

export class ServiceCategoryCategoryLookupTableDto implements IServiceCategoryCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IServiceCategoryCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ServiceCategoryCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceCategoryCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IServiceCategoryCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfServiceCategoryCategoryLookupTableDto implements IPagedResultDtoOfServiceCategoryCategoryLookupTableDto {
    totalCount!: number;
    items!: ServiceCategoryCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfServiceCategoryCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ServiceCategoryCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfServiceCategoryCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfServiceCategoryCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfServiceCategoryCategoryLookupTableDto {
    totalCount: number;
    items: ServiceCategoryCategoryLookupTableDto[] | undefined;
}


export class GetServiceCategoryForViewDto
    implements IGetServiceCategoryForViewDto {
    serviceCategory!: ServiceCategoryDto;
    serviceName!: string | undefined;
    categoryName!: string | undefined;

    constructor(data?: IGetServiceCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceCategory = data["serviceCategory"]
                ? ServiceCategoryDto.fromJS(data["serviceCategory"])
                : <any>undefined;
            this.serviceName = data["serviceName"];
            this.categoryName = data["categoryName"];
        }
    }

    static fromJS(data: any): GetServiceCategoryForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new GetServiceCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["serviceCategory"] = this.serviceCategory
            ? this.serviceCategory.toJSON()
            : <any>undefined;
        data["serviceName"] = this.serviceName;
        data["categoryName"] = this.categoryName;
        return data;
    }
}

export class ServiceCategoryDto implements IServiceCategoryDto {
    serviceId!: number | undefined;
    categoryId!: number | undefined;
    id!: number;

    constructor(data?: IServiceCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceId = data["serviceId"];
            this.categoryId = data["categoryId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServiceCategoryDto {
        data = typeof data === "object" ? data : {};
        let result = new ServiceCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["serviceId"] = this.serviceId;
        data["categoryId"] = this.categoryId;
        data["id"] = this.id;
        return data;
    }
}

export interface IServiceCategoryDto {
    serviceId: number | undefined;
    categoryId: number | undefined;
    id: number;
}

export interface IGetServiceCategoryForViewDto {
    serviceCategory: ServiceCategoryDto;
    serviceName: string | undefined;
    categoryName: string | undefined;
}

export class PagedResultDtoOfGetServiceCategoryForViewDto
    implements IPagedResultDtoOfGetServiceCategoryForViewDto {
    totalCount!: number;
    items!: GetServiceCategoryForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetServiceCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetServiceCategoryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetServiceCategoryForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfGetServiceCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetServiceCategoryForViewDto {
    totalCount: number;
    items: GetServiceCategoryForViewDto[] | undefined;
}

export class NameValueServiceOfString implements INameValueServiceOfString {
    name!: string | undefined;
    value!: string | undefined;
    serviceId!: string | undefined;

    constructor(data?: INameValueServiceOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
            this.serviceId = data["serviceId"];
        }
    }

    static fromJS(data: any): NameValueServiceOfString {
        data = typeof data === "object" ? data : {};
        let result = new NameValueServiceOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        data["serviceId"] = this.serviceId;
        return data;
    }
}

export interface INameValueServiceOfString {
    name: string | undefined;
    value: string | undefined;
    serviceId: string | undefined;
}
//#endregion

//#region ServicesImages
@Injectable()
export class ServiceImagesCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param urlFilter (optional) 
     * @param isMainFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param serviceNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, descriptionFilter: string | undefined, urlFilter: string | undefined, isMainFilter: number | undefined, isApprovedFilter: number | undefined, serviceNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetServiceImageForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ServiceImages/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&"; 
        if (isMainFilter === null)
            throw new Error("The parameter 'isMainFilter' cannot be null.");
        else if (isMainFilter !== undefined)
            url_ += "IsMainFilter=" + encodeURIComponent("" + isMainFilter) + "&"; 
        if (isApprovedFilter === null)
            throw new Error("The parameter 'isApprovedFilter' cannot be null.");
        else if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (serviceNameFilter === null)
            throw new Error("The parameter 'serviceNameFilter' cannot be null.");
        else if (serviceNameFilter !== undefined)
            url_ += "ServiceNameFilter=" + encodeURIComponent("" + serviceNameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetServiceImageForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetServiceImageForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetServiceImageForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetServiceImageForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetServiceImageForViewDto>(<any>null);
    }

    /**
     * @param productId
     * @return Success
     */
    getServiceImagesByServiceId(
        serviceId: number | undefined
    ): Observable<PagedResultDtoOfGetServiceImageForViewDto> {
        let url_ =
            this.baseUrl +
            "/api/services/app/ServiceImages/GetServiceImagesByServiceId?";
        if (serviceId === null)
            throw new Error("The parameter 'serviceId' cannot be null.");
        else if (serviceId !== undefined)
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };
        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetServiceImagesByServiceId(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetServiceImagesByServiceId(
                                <any>response_
                            );
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfGetServiceImageForViewDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<
                                PagedResultDtoOfGetServiceImageForViewDto
                            >
                        >(<any>_observableThrow(response_));
                })
            );
    }
    protected processGetServiceImagesByServiceId(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfGetServiceImageForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfGetServiceImageForViewDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfGetServiceImageForViewDto>(
            <any>null
        );
    }

    /**
     * @param body (optional)
     * @return Success
     */
    updateServiceImages(
        body: UpdateServiceImagesInput | undefined
    ): Observable<void> {
        let url_ =
            this.baseUrl +
            "/api/services/app/ServiceImages/UpdateServiceImages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json"
            })
        };
        return this.http
            .request("put", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateServiceImages(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateServiceImages(
                                <any>response_
                            );
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else
                        return <Observable<void>>(
                            (<any>_observableThrow(response_))
                        );
                })
            );
    }

    protected processUpdateServiceImages(
        response: HttpResponseBase
    ): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getServiceImageForView(id: number | undefined): Observable<GetServiceImageForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ServiceImages/GetServiceImageForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServiceImageForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServiceImageForView(<any>response_);
                } catch (e) {
                    return <Observable<GetServiceImageForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetServiceImageForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetServiceImageForView(response: HttpResponseBase): Observable<GetServiceImageForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetServiceImageForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetServiceImageForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getServiceImageForEdit(id: number | undefined): Observable<GetServiceImageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ServiceImages/GetServiceImageForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServiceImageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServiceImageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetServiceImageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetServiceImageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetServiceImageForEdit(response: HttpResponseBase): Observable<GetServiceImageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetServiceImageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetServiceImageForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditServiceImageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServiceImages/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }


    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServiceImages/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param urlFilter (optional) 
     * @param isMainFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param serviceNameFilter (optional) 
     * @return Success
     */
    getServiceImagesToExcel(filter: string | undefined, descriptionFilter: string | undefined, urlFilter: string | undefined, isMainFilter: number | undefined, isApprovedFilter: number | undefined, serviceNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ServiceImages/GetServiceImagesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&"; 
        if (isMainFilter === null)
            throw new Error("The parameter 'isMainFilter' cannot be null.");
        else if (isMainFilter !== undefined)
            url_ += "IsMainFilter=" + encodeURIComponent("" + isMainFilter) + "&"; 
        if (isApprovedFilter === null)
            throw new Error("The parameter 'isApprovedFilter' cannot be null.");
        else if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (serviceNameFilter === null)
            throw new Error("The parameter 'serviceNameFilter' cannot be null.");
        else if (serviceNameFilter !== undefined)
            url_ += "ServiceNameFilter=" + encodeURIComponent("" + serviceNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServiceImagesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServiceImagesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetServiceImagesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllServiceForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfServiceImageServiceLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ServiceImages/GetAllServiceForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllServiceForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllServiceForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfServiceImageServiceLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfServiceImageServiceLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllServiceForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfServiceImageServiceLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfServiceImageServiceLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfServiceImageServiceLookupTableDto>(<any>null);
    }

}
export class UpdateServiceImagesInput implements IUpdateServiceImagesInput {
    fileToken!: string | undefined;
    x!: number;
    y!: number;
    width!: number;
    height!: number;
    serviceId: number;
    fileName: string | undefined;
    fileType: string | undefined;
    description: string | undefined;
    imageBase64String: string | undefined;

    constructor(data?: IUpdateServiceImagesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
            this.serviceId = data["serviceId"];
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.description = data["description"];
            this.imageBase64String = data["imageBase64String"];
        }
    }

    static fromJS(data: any): UpdateServiceImagesInput {
        data = typeof data === "object" ? data : {};
        let result = new UpdateServiceImagesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        data["serviceId"] = this.serviceId;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["description"] = this.description;
        data["imageBase64String"] = this.imageBase64String;
        return data;
    }
}

export interface IUpdateServiceImagesInput {
    fileToken: string | undefined;
    x: number;
    y: number;
    width: number;
    height: number;
    serviceId: number;
    fileName: string | undefined;
    fileType: string | undefined;
    description: string | undefined;
    imageBase64String: string | undefined;
}

export class ServiceImageDto implements IServiceImageDto {
    description!: string | undefined;
    url!: string | undefined;
    isMain!: boolean;
    isApproved!: boolean;
    serviceId!: number | undefined;
    id!: number;
    imageBase64String: string | undefined;

    constructor(data?: IServiceImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.url = data["url"];
            this.isMain = data["isMain"];
            this.isApproved = data["isApproved"];
            this.serviceId = data["serviceId"];
            this.id = data["id"];
            this.imageBase64String = data["imageBase64String"];
        }
    }

    static fromJS(data: any): ServiceImageDto {
        data = typeof data === "object" ? data : {};
        let result = new ServiceImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["description"] = this.description;
        data["url"] = this.url;
        data["isMain"] = this.isMain;
        data["isApproved"] = this.isApproved;
        data["serviceId"] = this.serviceId;
        data["id"] = this.id;
        data["imageBase64String"] = this.imageBase64String;
        return data;
    }
}

export interface IServiceImageDto {
    description: string | undefined;
    url: string | undefined;
    isMain: boolean;
    isApproved: boolean;
    serviceId: number | undefined;
    id: number;
    imageBase64String: string | undefined;
}

export interface ICreateOrEditServiceImageDto {
    description: string | undefined;
    url: string | undefined;
    isMain: boolean;
    isApproved: boolean;
    serviceId: number | undefined;
    id: number | undefined;
}

export interface IGetServiceImageForViewDto {
    serviceImage: ServiceImageDto;
    serviceName: string | undefined;
}

export class ServiceImage {
    imageBase64String: string;
    imageId: number;
    fileDescr: string;
    url: string;
    isMain: boolean;
}
export interface IPagedResultDtoOfGetServiceImageForViewDto {
    totalCount: number;
    items: GetServiceImageForViewDto[] | undefined;
}

export class CreateOrEditServiceImageDto
    implements ICreateOrEditServiceImageDto {
    description!: string | undefined;
    url!: string | undefined;
    isMain!: boolean;
    isApproved!: boolean;
    serviceId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditServiceImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.url = data["url"];
            this.isMain = data["isMain"];
            this.isApproved = data["isApproved"];
            this.serviceId = data["serviceId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditServiceImageDto {
        data = typeof data === "object" ? data : {};
        let result = new CreateOrEditServiceImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["description"] = this.description;
        data["url"] = this.url;
        data["isMain"] = this.isMain;
        data["isApproved"] = this.isApproved;
        data["serviceId"] = this.serviceId;
        data["id"] = this.id;
        return data;
    }
}

export class GetServiceImageForViewDto implements IGetServiceImageForViewDto {
    serviceImage!: ServiceImageDto;
    serviceName!: string | undefined;

    constructor(data?: IGetServiceImageForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceImage = data["serviceImage"]
                ? ServiceImageDto.fromJS(data["serviceImage"])
                : <any>undefined;
            this.serviceName = data["serviceName"];
        }
    }

    static fromJS(data: any): GetServiceImageForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new GetServiceImageForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["serviceImage"] = this.serviceImage
            ? this.serviceImage.toJSON()
            : <any>undefined;
        data["serviceName"] = this.serviceName;
        return data;
    }
}

export class PagedResultDtoOfGetServiceImageForViewDto
    implements IPagedResultDtoOfGetServiceImageForViewDto {
    totalCount!: number;
    items!: GetServiceImageForViewDto[] | undefined;
    serviceImageList: ServiceImage[] = [];

    constructor(data?: IPagedResultDtoOfGetServiceImageForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;

                for (let item of data["items"]) {
                    var serviceImage = new ServiceImage();
                    serviceImage.imageBase64String =
                        "data:image/jpeg;base64," +
                        item.serviceImage.imageBase64String;
                    serviceImage.imageId = item.serviceImage.id;
                    serviceImage.fileDescr = item.serviceImage.description;
                    serviceImage.isMain = item.serviceImage.isMain;
                    serviceImage.url = item.serviceImage.url;

                    this.serviceImageList.push(serviceImage);
                    this.items!.push(GetServiceImageForViewDto.fromJS(item));
                }
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetServiceImageForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfGetServiceImageForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}



export class GetServiceImageForEditOutput implements IGetServiceImageForEditOutput {
    serviceImage!: CreateOrEditServiceImageDto;
    serviceName!: string | undefined;

    constructor(data?: IGetServiceImageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceImage = data["serviceImage"] ? CreateOrEditServiceImageDto.fromJS(data["serviceImage"]) : <any>undefined;
            this.serviceName = data["serviceName"];
        }
    }

    static fromJS(data: any): GetServiceImageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetServiceImageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceImage"] = this.serviceImage ? this.serviceImage.toJSON() : <any>undefined;
        data["serviceName"] = this.serviceName;
        return data; 
    }
}

export interface IGetServiceImageForEditOutput {
    serviceImage: CreateOrEditServiceImageDto;
    serviceName: string | undefined;
}


export class ServiceImageServiceLookupTableDto implements IServiceImageServiceLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IServiceImageServiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ServiceImageServiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceImageServiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IServiceImageServiceLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfServiceImageServiceLookupTableDto implements IPagedResultDtoOfServiceImageServiceLookupTableDto {
    totalCount!: number;
    items!: ServiceImageServiceLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfServiceImageServiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ServiceImageServiceLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfServiceImageServiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfServiceImageServiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfServiceImageServiceLookupTableDto {
    totalCount: number;
    items: ServiceImageServiceLookupTableDto[] | undefined;
}

//#endregion

//#region ServicePrices
@Injectable()
export class ServicePricesCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxPriceFilter (optional) 
     * @param minPriceFilter (optional) 
     * @param maxValidityFilter (optional) 
     * @param minValidityFilter (optional) 
     * @param serviceNameFilter (optional) 
     * @param serviceIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxPriceFilter: number | undefined, minPriceFilter: number | undefined, maxValidityFilter: moment.Moment | undefined, minValidityFilter: moment.Moment | undefined, serviceNameFilter: string | undefined, serviceIdFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetServicePriceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ServicePrices/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxPriceFilter === null)
            throw new Error("The parameter 'maxPriceFilter' cannot be null.");
        else if (maxPriceFilter !== undefined)
            url_ += "MaxPriceFilter=" + encodeURIComponent("" + maxPriceFilter) + "&"; 
        if (minPriceFilter === null)
            throw new Error("The parameter 'minPriceFilter' cannot be null.");
        else if (minPriceFilter !== undefined)
            url_ += "MinPriceFilter=" + encodeURIComponent("" + minPriceFilter) + "&"; 
        if (maxValidityFilter === null)
            throw new Error("The parameter 'maxValidityFilter' cannot be null.");
        else if (maxValidityFilter !== undefined)
            url_ += "MaxValidityFilter=" + encodeURIComponent(maxValidityFilter ? "" + maxValidityFilter.toJSON() : "") + "&"; 
        if (minValidityFilter === null)
            throw new Error("The parameter 'minValidityFilter' cannot be null.");
        else if (minValidityFilter !== undefined)
            url_ += "MinValidityFilter=" + encodeURIComponent(minValidityFilter ? "" + minValidityFilter.toJSON() : "") + "&"; 
        if (serviceNameFilter === null)
            throw new Error("The parameter 'serviceNameFilter' cannot be null.");
        else if (serviceNameFilter !== undefined)
            url_ += "ServiceNameFilter=" + encodeURIComponent("" + serviceNameFilter) + "&"; 
        if (serviceIdFilter === null)
            throw new Error("The parameter 'serviceIdFilter' cannot be null.");
        else if (serviceIdFilter !== undefined)
            url_ += "ServiceIdFilter=" + encodeURIComponent("" + serviceIdFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetServicePriceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetServicePriceForViewDto>><any>_observableThrow(response_);
        }));
    }    

    /**
     * @param filter (optional)
     * @param maxPriceFilter (optional)
     * @param minPriceFilter (optional)
     * @param maxValidityFilter (optional)
     * @param minValidityFilter (optional)
     * @param serviceNameFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    GetByServiceId(
        serviceIdFilter: number | undefined,
        sorting: string | undefined,
        skipCount: number | undefined,
        maxResultCount: number | undefined
    ): Observable<PagedResultDtoOfGetServicePriceForViewDto> {
        let url_ =
            this.baseUrl + "/api/services/app/ServicePrices/GetByServiceId?";
        if (serviceIdFilter === null)
            throw new Error("The parameter 'serviceIdFilter' cannot be null.");
        else if (serviceIdFilter !== undefined)
            url_ +=
                "serviceIdFilter=" +
                encodeURIComponent("" + serviceIdFilter) +
                "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ +=
                "MaxResultCount=" +
                encodeURIComponent("" + maxResultCount) +
                "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetAll(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetAll(<any>response_);
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfGetServicePriceForViewDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<
                                PagedResultDtoOfGetServicePriceForViewDto
                            >
                        >(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetAll(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfGetServicePriceForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfGetServicePriceForViewDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfGetServicePriceForViewDto>(
            <any>null
        );
    }

    protected processGetByServiceId(response: HttpResponseBase): Observable<PagedResultDtoOfGetServicePriceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetServicePriceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetServicePriceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getServicePriceForView(id: number | undefined): Observable<GetServicePriceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ServicePrices/GetServicePriceForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServicePriceForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServicePriceForView(<any>response_);
                } catch (e) {
                    return <Observable<GetServicePriceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetServicePriceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetServicePriceForView(response: HttpResponseBase): Observable<GetServicePriceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetServicePriceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetServicePriceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getServicePriceForEdit(id: number | undefined): Observable<GetServicePriceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ServicePrices/GetServicePriceForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServicePriceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServicePriceForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetServicePriceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetServicePriceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetServicePriceForEdit(response: HttpResponseBase): Observable<GetServicePriceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetServicePriceForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetServicePriceForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditServicePriceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServicePrices/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServicePrices/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxPriceFilter (optional) 
     * @param minPriceFilter (optional) 
     * @param maxValidityFilter (optional) 
     * @param minValidityFilter (optional) 
     * @param serviceNameFilter (optional) 
     * @return Success
     */
    getServicePricesToExcel(filter: string | undefined, maxPriceFilter: number | undefined, minPriceFilter: number | undefined, maxValidityFilter: moment.Moment | undefined, minValidityFilter: moment.Moment | undefined, serviceNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ServicePrices/GetServicePricesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxPriceFilter === null)
            throw new Error("The parameter 'maxPriceFilter' cannot be null.");
        else if (maxPriceFilter !== undefined)
            url_ += "MaxPriceFilter=" + encodeURIComponent("" + maxPriceFilter) + "&"; 
        if (minPriceFilter === null)
            throw new Error("The parameter 'minPriceFilter' cannot be null.");
        else if (minPriceFilter !== undefined)
            url_ += "MinPriceFilter=" + encodeURIComponent("" + minPriceFilter) + "&"; 
        if (maxValidityFilter === null)
            throw new Error("The parameter 'maxValidityFilter' cannot be null.");
        else if (maxValidityFilter !== undefined)
            url_ += "MaxValidityFilter=" + encodeURIComponent(maxValidityFilter ? "" + maxValidityFilter.toJSON() : "") + "&"; 
        if (minValidityFilter === null)
            throw new Error("The parameter 'minValidityFilter' cannot be null.");
        else if (minValidityFilter !== undefined)
            url_ += "MinValidityFilter=" + encodeURIComponent(minValidityFilter ? "" + minValidityFilter.toJSON() : "") + "&"; 
        if (serviceNameFilter === null)
            throw new Error("The parameter 'serviceNameFilter' cannot be null.");
        else if (serviceNameFilter !== undefined)
            url_ += "ServiceNameFilter=" + encodeURIComponent("" + serviceNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServicePricesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServicePricesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetServicePricesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllServiceForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfServicePriceServiceLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ServicePrices/GetAllServiceForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllServiceForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllServiceForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfServicePriceServiceLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfServicePriceServiceLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllServiceForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfServicePriceServiceLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfServicePriceServiceLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfServicePriceServiceLookupTableDto>(<any>null);
    }
}

export class PagedResultDtoOfGetServicePriceForViewDto
    implements IPagedResultDtoOfGetServicePriceForViewDto {
    totalCount!: number;
    items!: GetServicePriceForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetServicePriceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetServicePriceForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetServicePriceForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfGetServicePriceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetServicePriceForViewDto {
    totalCount: number;
    items: GetServicePriceForViewDto[] | undefined;
}

export class GetServicePriceForViewDto implements IGetServicePriceForViewDto {
    servicePrice!: ServicePriceDto;
    serviceName!: string | undefined;

    constructor(data?: IGetServicePriceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.servicePrice = data["servicePrice"]
                ? ServicePriceDto.fromJS(data["servicePrice"])
                : <any>undefined;
            this.serviceName = data["serviceName"];
        }
    }

    static fromJS(data: any): GetServicePriceForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new GetServicePriceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["servicePrice"] = this.servicePrice
            ? this.servicePrice.toJSON()
            : <any>undefined;
        data["serviceName"] = this.serviceName;
        return data;
    }
}

export interface IGetServicePriceForViewDto {
    servicePrice: ServicePriceDto;
    serviceName: string | undefined;
}

export class ServicePriceDto implements IServicePriceDto {
    price!: number;
    validity!: moment.Moment;
    serviceId!: number | undefined;
    id!: number;

    constructor(data?: IServicePriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.price = data["price"];
            this.validity = data["validity"]
                ? moment(data["validity"].toString())
                : <any>undefined;
            this.serviceId = data["serviceId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServicePriceDto {
        data = typeof data === "object" ? data : {};
        let result = new ServicePriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["price"] = this.price;
        data["validity"] = this.validity
            ? this.validity.toISOString()
            : <any>undefined;
        data["serviceId"] = this.serviceId;
        data["id"] = this.id;
        return data;
    }
}

export interface IServicePriceDto {
    price: number;
    validity: moment.Moment;
    serviceId: number | undefined;
    id: number;
}

export class CreateOrEditServicePriceDto implements ICreateOrEditServicePriceDto {
    price!: number;
    validity!: moment.Moment;
    serviceId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditServicePriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.price = data["price"];
            this.validity = data["validity"] ? moment(data["validity"].toString()) : <any>undefined;
            this.serviceId = data["serviceId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditServicePriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditServicePriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["price"] = this.price;
        data["validity"] = this.validity ? this.validity.toISOString() : <any>undefined;
        data["serviceId"] = this.serviceId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditServicePriceDto {
    price: number;
    validity: moment.Moment;
    serviceId: number | undefined;
    id: number | undefined;
}

export class GetServicePriceForEditOutput implements IGetServicePriceForEditOutput {
    servicePrice!: CreateOrEditServicePriceDto;
    serviceName!: string | undefined;

    constructor(data?: IGetServicePriceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.servicePrice = data["servicePrice"] ? CreateOrEditServicePriceDto.fromJS(data["servicePrice"]) : <any>undefined;
            this.serviceName = data["serviceName"];
        }
    }

    static fromJS(data: any): GetServicePriceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetServicePriceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["servicePrice"] = this.servicePrice ? this.servicePrice.toJSON() : <any>undefined;
        data["serviceName"] = this.serviceName;
        return data; 
    }
}

export interface IGetServicePriceForEditOutput {
    servicePrice: CreateOrEditServicePriceDto;
    serviceName: string | undefined;
}

export class ServicePriceServiceLookupTableDto implements IServicePriceServiceLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IServicePriceServiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ServicePriceServiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePriceServiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IServicePriceServiceLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfServicePriceServiceLookupTableDto implements IPagedResultDtoOfServicePriceServiceLookupTableDto {
    totalCount!: number;
    items!: ServicePriceServiceLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfServicePriceServiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ServicePriceServiceLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfServicePriceServiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfServicePriceServiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfServicePriceServiceLookupTableDto {
    totalCount: number;
    items: ServicePriceServiceLookupTableDto[] | undefined;
}
//#endregion

//#region SysRefs
@Injectable()
export class SysRefsCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param refCodeFilter (optional)
     * @param descriptionFilter (optional)
     * @param referenceTypeNameFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getCustomAll(
        filter: string | undefined,
        refCodeFilter: string | undefined,
        descriptionFilter: string | undefined,
        referenceTypeNameFilter: string | undefined,
        referenceTypeIdFilter: number | undefined,
        sorting: string | undefined,
        skipCount: number | undefined,
        maxResultCount: number | undefined
    ): Observable<PagedResultDtoOfGetSysRefForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonQuery/GetSysRef_All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (refCodeFilter === null)
            throw new Error("The parameter 'refCodeFilter' cannot be null.");
        else if (refCodeFilter !== undefined)
            url_ +=
                "RefCodeFilter=" + encodeURIComponent("" + refCodeFilter) + "&";
        if (descriptionFilter === null)
            throw new Error(
                "The parameter 'descriptionFilter' cannot be null."
            );
        else if (descriptionFilter !== undefined)
            url_ +=
                "DescriptionFilter=" +
                encodeURIComponent("" + descriptionFilter) +
                "&";
        if (referenceTypeNameFilter === null)
            throw new Error(
                "The parameter 'referenceTypeNameFilter' cannot be null."
            );
        else if (referenceTypeNameFilter !== undefined)
            url_ +=
                "ReferenceTypeNameFilter=" +
                encodeURIComponent("" + referenceTypeNameFilter) +
                "&";
        if (referenceTypeIdFilter === null)
            throw new Error(
                "The parameter 'referenceTypeIdFilter' cannot be null."
            );
        else if (referenceTypeIdFilter !== undefined)
            url_ +=
                "referenceTypeIdFilter=" +
                encodeURIComponent("" + referenceTypeIdFilter) +
                "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ +=
                "MaxResultCount=" +
                encodeURIComponent("" + maxResultCount) +
                "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };
        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCustomAll(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCustomAll(<any>response_);
                        } catch (e) {
                            return <
                                Observable<PagedResultDtoOfGetSysRefForViewDto>
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<PagedResultDtoOfGetSysRefForViewDto>
                        >(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetCustomAll(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfGetSysRefForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfGetSysRefForViewDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfGetSysRefForViewDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    GetSysRefByRefType(
        ReferenceTypeNameFilter: string | undefined,
        RefCodeFilter: string | undefined,
    ): Observable<PagedResultDtoOfServiceSysRefLookupTableDto> {
        let url_ =
            this.baseUrl + "/api/services/app/Services/GetSysRefByRefType?";
        if (ReferenceTypeNameFilter === null)
            throw new Error("The parameter 'ReferenceTypeNameFilter' cannot be null.");
        else if (ReferenceTypeNameFilter !== undefined)
            url_ += "ReferenceTypeNameFilter=" + encodeURIComponent("" + ReferenceTypeNameFilter) + "&";
        if (RefCodeFilter === null)
            throw new Error("The parameter 'RefCodeFilter' cannot be null.");
        else if (RefCodeFilter !== undefined)
            url_ += "RefCodeFilter=" + encodeURIComponent("" + RefCodeFilter) + "&";

        url_ = url_.replace(/[?&]$/, "");
        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetRefSysByRefType(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetRefSysByRefType(
                                <any>response_
                            );
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfServiceSysRefLookupTableDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<
                                PagedResultDtoOfServiceSysRefLookupTableDto
                            >
                        >(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetRefSysByRefType(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfServiceSysRefLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfServiceSysRefLookupTableDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfServiceSysRefLookupTableDto>(
            <any>null
        );
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSysRefForView(id: number | undefined): Observable<GetSysRefForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SysRefs/GetSysRefForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSysRefForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSysRefForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSysRefForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSysRefForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSysRefForView(response: HttpResponseBase): Observable<GetSysRefForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSysRefForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSysRefForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSysRefForEdit(id: number | undefined): Observable<GetSysRefForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SysRefs/GetSysRefForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSysRefForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSysRefForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSysRefForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSysRefForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSysRefForEdit(response: HttpResponseBase): Observable<GetSysRefForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSysRefForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSysRefForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSysRefDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SysRefs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SysRefs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param refCodeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxOrderNumberFilter (optional) 
     * @param minOrderNumberFilter (optional) 
     * @param referenceTypeNameFilter (optional) 
     * @return Success
     */
    getSysRefsToExcel(filter: string | undefined, refCodeFilter: string | undefined, descriptionFilter: string | undefined, maxOrderNumberFilter: number | undefined, minOrderNumberFilter: number | undefined, referenceTypeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SysRefs/GetSysRefsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (refCodeFilter === null)
            throw new Error("The parameter 'refCodeFilter' cannot be null.");
        else if (refCodeFilter !== undefined)
            url_ += "RefCodeFilter=" + encodeURIComponent("" + refCodeFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxOrderNumberFilter === null)
            throw new Error("The parameter 'maxOrderNumberFilter' cannot be null.");
        else if (maxOrderNumberFilter !== undefined)
            url_ += "MaxOrderNumberFilter=" + encodeURIComponent("" + maxOrderNumberFilter) + "&"; 
        if (minOrderNumberFilter === null)
            throw new Error("The parameter 'minOrderNumberFilter' cannot be null.");
        else if (minOrderNumberFilter !== undefined)
            url_ += "MinOrderNumberFilter=" + encodeURIComponent("" + minOrderNumberFilter) + "&"; 
        if (referenceTypeNameFilter === null)
            throw new Error("The parameter 'referenceTypeNameFilter' cannot be null.");
        else if (referenceTypeNameFilter !== undefined)
            url_ += "ReferenceTypeNameFilter=" + encodeURIComponent("" + referenceTypeNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSysRefsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSysRefsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSysRefsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllReferenceTypeForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfSysRefReferenceTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SysRefs/GetAllReferenceTypeForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllReferenceTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllReferenceTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSysRefReferenceTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSysRefReferenceTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllReferenceTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSysRefReferenceTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSysRefReferenceTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSysRefReferenceTypeLookupTableDto>(<any>null);
    }

}

export class PagedResultDtoOfGetSysRefForViewDto
    implements IPagedResultDtoOfGetSysRefForViewDto {
    totalCount!: number;
    items!: GetSysRefForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSysRefForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSysRefForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSysRefForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfGetSysRefForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSysRefForViewDto {
    totalCount: number;
    items: GetSysRefForViewDto[] | undefined;
}

export class GetSysRefForViewDto implements IGetSysRefForViewDto {
    sysRef!: SysRefDto;
    referenceTypeName!: string | undefined;

    constructor(data?: IGetSysRefForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sysRef = data["sysRef"]
                ? SysRefDto.fromJS(data["sysRef"])
                : <any>undefined;
            this.referenceTypeName = data["referenceTypeName"];
        }
    }

    static fromJS(data: any): GetSysRefForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new GetSysRefForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["sysRef"] = this.sysRef ? this.sysRef.toJSON() : <any>undefined;
        data["referenceTypeName"] = this.referenceTypeName;
        return data;
    }
}

export interface IGetSysRefForViewDto {
    sysRef: SysRefDto;
    referenceTypeName: string | undefined;
}

export class SysRefDto implements ISysRefDto {
    refCode!: string | undefined;
    description!: string | undefined;
    orderNumber!: number;
    referenceTypeId!: number | undefined;
    id!: number;

    constructor(data?: ISysRefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.refCode = data["refCode"];
            this.description = data["description"];
            this.orderNumber = data["orderNumber"];
            this.referenceTypeId = data["referenceTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SysRefDto {
        data = typeof data === 'object' ? data : {};
        let result = new SysRefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refCode"] = this.refCode;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["referenceTypeId"] = this.referenceTypeId;
        data["id"] = this.id;
        return data; 
    }
}


export interface ISysRefDto {
    refCode: string | undefined;
    description: string | undefined;
    orderNumber: number;
    referenceTypeId: number | undefined;
    id: number;
}

export interface IGetSysRefForViewDto {
    sysRef: SysRefDto;
    referenceTypeName: string | undefined;
}

export interface IPagedResultDtoOfGetSysRefForViewDto {
    totalCount: number;
    items: GetSysRefForViewDto[] | undefined;
}

export class CreateOrEditSysRefDto implements ICreateOrEditSysRefDto {
    refCode!: string | undefined;
    description!: string | undefined;
    orderNumber!: number;
    referenceTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditSysRefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.refCode = data["refCode"];
            this.description = data["description"];
            this.orderNumber = data["orderNumber"];
            this.referenceTypeId = data["referenceTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSysRefDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSysRefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refCode"] = this.refCode;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["referenceTypeId"] = this.referenceTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditSysRefDto {
    refCode: string | undefined;
    description: string | undefined;
    orderNumber: number;
    referenceTypeId: number | undefined;
    id: number | undefined;
}

export class GetSysRefForEditOutput implements IGetSysRefForEditOutput {
    sysRef!: CreateOrEditSysRefDto;
    referenceTypeName!: string | undefined;

    constructor(data?: IGetSysRefForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sysRef = data["sysRef"] ? CreateOrEditSysRefDto.fromJS(data["sysRef"]) : <any>undefined;
            this.referenceTypeName = data["referenceTypeName"];
        }
    }

    static fromJS(data: any): GetSysRefForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSysRefForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sysRef"] = this.sysRef ? this.sysRef.toJSON() : <any>undefined;
        data["referenceTypeName"] = this.referenceTypeName;
        return data; 
    }
}

export interface IGetSysRefForEditOutput {
    sysRef: CreateOrEditSysRefDto;
    referenceTypeName: string | undefined;
}

export class SysRefReferenceTypeLookupTableDto implements ISysRefReferenceTypeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ISysRefReferenceTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): SysRefReferenceTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SysRefReferenceTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ISysRefReferenceTypeLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfSysRefReferenceTypeLookupTableDto implements IPagedResultDtoOfSysRefReferenceTypeLookupTableDto {
    totalCount!: number;
    items!: SysRefReferenceTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSysRefReferenceTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SysRefReferenceTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSysRefReferenceTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSysRefReferenceTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSysRefReferenceTypeLookupTableDto {
    totalCount: number;
    items: SysRefReferenceTypeLookupTableDto[] | undefined;
}
//#endregion

//#region SysStatuses
@Injectable()
export class SysStatusesCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param maxCodeFilter (optional)
     * @param minCodeFilter (optional)
     * @param nameFilter (optional)
     * @param descriptionFilter (optional)
     * @param sysRefTenantIdFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getCustomAll(
        filter: string | undefined,
        maxCodeFilter: number | undefined,
        minCodeFilter: number | undefined,
        nameFilter: string | undefined,
        descriptionFilter: string | undefined,
        sysRefTenantIdFilter: string | undefined,
        refCodeFilter: string | undefined,
        sorting: string | undefined,
        skipCount: number | undefined,
        maxResultCount: number | undefined
    ): Observable<PagedResultDtoOfGetSysStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonQuery/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxCodeFilter === null)
            throw new Error("The parameter 'maxCodeFilter' cannot be null.");
        else if (maxCodeFilter !== undefined)
            url_ +=
                "MaxCodeFilter=" + encodeURIComponent("" + maxCodeFilter) + "&";
        if (minCodeFilter === null)
            throw new Error("The parameter 'minCodeFilter' cannot be null.");
        else if (minCodeFilter !== undefined)
            url_ +=
                "MinCodeFilter=" + encodeURIComponent("" + minCodeFilter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error(
                "The parameter 'descriptionFilter' cannot be null."
            );
        else if (descriptionFilter !== undefined)
            url_ +=
                "DescriptionFilter=" +
                encodeURIComponent("" + descriptionFilter) +
                "&";
        if (sysRefTenantIdFilter === null)
            throw new Error(
                "The parameter 'sysRefTenantIdFilter' cannot be null."
            );
        else if (sysRefTenantIdFilter !== undefined)
            url_ +=
                "SysRefTenantIdFilter=" +
                encodeURIComponent("" + sysRefTenantIdFilter) +
                "&";
        if (refCodeFilter === null)
            throw new Error("The parameter 'refCodeFilter' cannot be null.");
        else if (refCodeFilter !== undefined)
            url_ +=
                "RefCodeFilter=" + encodeURIComponent("" + refCodeFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ +=
                "MaxResultCount=" +
                encodeURIComponent("" + maxResultCount) +
                "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCustomGetAll(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCustomGetAll(<any>response_);
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfGetSysStatusForViewDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<PagedResultDtoOfGetSysStatusForViewDto>
                        >(<any>_observableThrow(response_));
                })
            );
    }

    protected processCustomGetAll(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfGetSysStatusForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfGetSysStatusForViewDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfGetSysStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSysStatusForView(id: number | undefined): Observable<GetSysStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SysStatuses/GetSysStatusForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSysStatusForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSysStatusForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSysStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSysStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSysStatusForView(response: HttpResponseBase): Observable<GetSysStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSysStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSysStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSysStatusForEdit(id: number | undefined): Observable<GetSysStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SysStatuses/GetSysStatusForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSysStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSysStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSysStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSysStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSysStatusForEdit(response: HttpResponseBase): Observable<GetSysStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSysStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSysStatusForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSysStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SysStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SysStatuses/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxCodeFilter (optional) 
     * @param minCodeFilter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sysRefTenantIdFilter (optional) 
     * @return Success
     */
    getSysStatusesToExcel(filter: string | undefined, maxCodeFilter: number | undefined, minCodeFilter: number | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, sysRefTenantIdFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SysStatuses/GetSysStatusesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxCodeFilter === null)
            throw new Error("The parameter 'maxCodeFilter' cannot be null.");
        else if (maxCodeFilter !== undefined)
            url_ += "MaxCodeFilter=" + encodeURIComponent("" + maxCodeFilter) + "&"; 
        if (minCodeFilter === null)
            throw new Error("The parameter 'minCodeFilter' cannot be null.");
        else if (minCodeFilter !== undefined)
            url_ += "MinCodeFilter=" + encodeURIComponent("" + minCodeFilter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sysRefTenantIdFilter === null)
            throw new Error("The parameter 'sysRefTenantIdFilter' cannot be null.");
        else if (sysRefTenantIdFilter !== undefined)
            url_ += "SysRefTenantIdFilter=" + encodeURIComponent("" + sysRefTenantIdFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSysStatusesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSysStatusesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSysStatusesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysRefForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfSysStatusesysRefLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SysStatuses/GetAllSysRefForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysRefForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysRefForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSysStatusesysRefLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSysStatusesysRefLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysRefForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSysStatusesysRefLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSysStatusesysRefLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSysStatusesysRefLookupTableDto>(<any>null);
    }
}

export class PagedResultDtoOfGetSysStatusForViewDto
    implements IPagedResultDtoOfGetSysStatusForViewDto {
    totalCount!: number;
    items!: GetSysStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSysStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSysStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSysStatusForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfGetSysStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSysStatusForViewDto {
    totalCount: number;
    items: GetSysStatusForViewDto[] | undefined;
}

export class GetSysStatusForViewDto implements IGetSysStatusForViewDto {
    sysStatus!: SysStatusDto;
    sysRefTenantId!: string | undefined;

    constructor(data?: IGetSysStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sysStatus = data["sysStatus"]
                ? SysStatusDto.fromJS(data["sysStatus"])
                : <any>undefined;
            this.sysRefTenantId = data["sysRefTenantId"];
        }
    }

    static fromJS(data: any): GetSysStatusForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new GetSysStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["sysStatus"] = this.sysStatus
            ? this.sysStatus.toJSON()
            : <any>undefined;
        data["sysRefTenantId"] = this.sysRefTenantId;
        return data;
    }
}

export interface IGetSysStatusForViewDto {
    sysStatus: SysStatusDto;
    sysRefTenantId: string | undefined;
}

export class SysStatusDto implements ISysStatusDto {
    code!: number;
    name!: string | undefined;
    description!: string | undefined;
    sysRefId!: number | undefined;
    id!: number;
    refCode!: string | undefined;

    constructor(data?: ISysStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.description = data["description"];
            this.sysRefId = data["sysRefId"];
            this.id = data["id"];
            this.refCode = data["refCode"];
        }
    }

    static fromJS(data: any): SysStatusDto {
        data = typeof data === "object" ? data : {};
        let result = new SysStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sysRefId"] = this.sysRefId;
        data["id"] = this.id;
        data["refCode"] = this.refCode;
        return data;
    }
}

export interface ISysStatusDto {
    code: number;
    name: string | undefined;
    description: string | undefined;
    sysRefId: number | undefined;
    id: number;
    refCode: string | undefined;
}

export class StatusList implements IStatusList {
    New!: number | undefined;
    Require!: number | undefined;
    Pending!: number | undefined;
    Approved!: number | undefined;
    Rejected!: number | undefined;

    constructor(data?: IStatusList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.New = data["New"];
            this.Require = data["Require"];
            this.Pending = data["Pending"];
            this.Approved = data["Approved"];
            this.Rejected = data["Rejected"];
        }
    }

    static fromJS(data: any): StatusList {
        data = typeof data === "object" ? data : {};
        let result = new StatusList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["New"] = this.New;
        data["Require"] = this.Require;
        data["Pending"] = this.Pending;
        data["Approved"] = this.Approved;
        data["Rejected"] = this.Rejected;
        return data;
    }
}

export interface IStatusList {
    New: number | undefined;
    Require: number | undefined;
    Pending: number | undefined;
    Approved: number | undefined;
    Rejected: number | undefined;
}

export interface IPagedResultDtoOfGetSysStatusForViewDto {
    totalCount: number;
    items: GetSysStatusForViewDto[] | undefined;
}

export class CreateOrEditSysStatusDto implements ICreateOrEditSysStatusDto {
    code!: number;
    name!: string | undefined;
    description!: string | undefined;
    sysRefId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditSysStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.description = data["description"];
            this.sysRefId = data["sysRefId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSysStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSysStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sysRefId"] = this.sysRefId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditSysStatusDto {
    code: number;
    name: string | undefined;
    description: string | undefined;
    sysRefId: number | undefined;
    id: number | undefined;
}

export class GetSysStatusForEditOutput implements IGetSysStatusForEditOutput {
    sysStatus!: CreateOrEditSysStatusDto;
    sysRefTenantId!: string | undefined;

    constructor(data?: IGetSysStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sysStatus = data["sysStatus"] ? CreateOrEditSysStatusDto.fromJS(data["sysStatus"]) : <any>undefined;
            this.sysRefTenantId = data["sysRefTenantId"];
        }
    }

    static fromJS(data: any): GetSysStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSysStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sysStatus"] = this.sysStatus ? this.sysStatus.toJSON() : <any>undefined;
        data["sysRefTenantId"] = this.sysRefTenantId;
        return data; 
    }
}

export interface IGetSysStatusForEditOutput {
    sysStatus: CreateOrEditSysStatusDto;
    sysRefTenantId: string | undefined;
}

export class SysStatusesysRefLookupTableDto implements ISysStatusesysRefLookupTableDto {
    id!: number;
    displayName!: string | undefined;
    refCode!: string | undefined;

    constructor(data?: ISysStatusesysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.refCode = data["refCode"];
        }
    }

    static fromJS(data: any): SysStatusesysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SysStatusesysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["refCode"] = this.refCode;
        return data; 
    }
}

export interface ISysStatusesysRefLookupTableDto {
    id: number;
    displayName: string | undefined;
    refCode: string | undefined;
}

export class PagedResultDtoOfSysStatusesysRefLookupTableDto implements IPagedResultDtoOfSysStatusesysRefLookupTableDto {
    totalCount!: number;
    items!: SysStatusesysRefLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSysStatusesysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SysStatusesysRefLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSysStatusesysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSysStatusesysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSysStatusesysRefLookupTableDto {
    totalCount: number;
    items: SysStatusesysRefLookupTableDto[] | undefined;
}
//#endregion

//#region Team
@Injectable()
export class TeamsCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }
    
    
    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param remarkFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @param referenceTypeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, isActiveFilter: number | undefined, remarkFilter: string | undefined, sysStatusNameFilter: string | undefined, referenceTypeNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTeamForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Teams/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        if (referenceTypeNameFilter === null)
            throw new Error("The parameter 'referenceTypeNameFilter' cannot be null.");
        else if (referenceTypeNameFilter !== undefined)
            url_ += "ReferenceTypeNameFilter=" + encodeURIComponent("" + referenceTypeNameFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTeamForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTeamForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTeamForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetTeamForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTeamForViewDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    GetAllSysStatusForLookupTableByRefCode(
        filter: string | undefined,
        refType: string | undefined,
        refCode: string | undefined,
        sorting: string | undefined,
        skipCount: number | undefined,
        maxResultCount: number | undefined
    ): Observable<PagedResultDtoOfTeamSysStatusLookupTableDto> {
        let url_ =
            this.baseUrl +
            "/api/services/app/Teams/GetAllSysStatusForLookupTableByRefCode?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (refType === null)
            throw new Error("The parameter 'refType' cannot be null.");
        else if (refType !== undefined)
            url_ += "ReferenceType=" + encodeURIComponent("" + refType) + "&";
        if (refCode === null)
            throw new Error("The parameter 'refCode' cannot be null.");
        else if (refCode !== undefined)
            url_ += "refCode=" + encodeURIComponent("" + refCode) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ +=
                "MaxResultCount=" +
                encodeURIComponent("" + maxResultCount) +
                "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetAllSysStatusForLookupTableByRefCode(
                        response_
                    );
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetAllSysStatusForLookupTableByRefCode(
                                <any>response_
                            );
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfTeamSysStatusLookupTableDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<
                                PagedResultDtoOfTeamSysStatusLookupTableDto
                            >
                        >(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetAllSysStatusForLookupTableByRefCode(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfTeamSysStatusLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfTeamSysStatusLookupTableDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfTeamSysStatusLookupTableDto>(
            <any>null
        );
    }
    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getCustomAllReferenceTypeForLookupTable(
        filter: string | undefined,
        referenceTypeGroupFilter: string | undefined,
        sorting: string | undefined,
        skipCount: number | undefined,
        maxResultCount: number | undefined
    ): Observable<PagedResultDtoOfTeamReferenceTypeLookupTableDto> {
        let url_ =
            this.baseUrl +
            "/api/services/app/Teams/GetAllReferenceTypeForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (referenceTypeGroupFilter === null)
            throw new Error(
                "The parameter 'referenceTypeGroup' cannot be null."
            );
        else if (referenceTypeGroupFilter !== undefined)
            url_ +=
                "ReferenceTypeGroupFilter=" +
                encodeURIComponent("" + referenceTypeGroupFilter) +
                "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ +=
                "MaxResultCount=" +
                encodeURIComponent("" + maxResultCount) +
                "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCustomAllReferenceTypeForLookupTable(
                        response_
                    );
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCustomAllReferenceTypeForLookupTable(
                                <any>response_
                            );
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfTeamReferenceTypeLookupTableDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<
                                PagedResultDtoOfTeamReferenceTypeLookupTableDto
                            >
                        >(<any>_observableThrow(response_));
                })
            );
    }
    protected processGetCustomAllReferenceTypeForLookupTable(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfTeamReferenceTypeLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfTeamReferenceTypeLookupTableDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfTeamReferenceTypeLookupTableDto>(
            <any>null
        );
    }

   
    /**
     * @param id (optional) 
     * @return Success
     */
    getTeamForEdit(id: number | undefined): Observable<GetTeamForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Teams/GetTeamForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeamForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeamForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTeamForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTeamForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTeamForEdit(response: HttpResponseBase): Observable<GetTeamForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTeamForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTeamForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTeamDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Teams/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Teams/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param remarkFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @param referenceTypeNameFilter (optional) 
     * @return Success
     */
    getTeamsToExcel(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, isActiveFilter: number | undefined, remarkFilter: string | undefined, sysStatusNameFilter: string | undefined, referenceTypeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Teams/GetTeamsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        if (referenceTypeNameFilter === null)
            throw new Error("The parameter 'referenceTypeNameFilter' cannot be null.");
        else if (referenceTypeNameFilter !== undefined)
            url_ += "ReferenceTypeNameFilter=" + encodeURIComponent("" + referenceTypeNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeamsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeamsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTeamsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param referenceTypeGroupFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysStatusForLookupTable(filter: string | undefined, referenceTypeGroupFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTeamSysStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Teams/GetAllSysStatusForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceTypeGroupFilter === null)
            throw new Error("The parameter 'referenceTypeGroupFilter' cannot be null.");
        else if (referenceTypeGroupFilter !== undefined)
            url_ += "ReferenceTypeGroupFilter=" + encodeURIComponent("" + referenceTypeGroupFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTeamSysStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTeamSysStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTeamSysStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTeamSysStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTeamSysStatusLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param referenceTypeGroupFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllReferenceTypeForLookupTable(filter: string | undefined, referenceTypeGroupFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTeamReferenceTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Teams/GetAllReferenceTypeForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceTypeGroupFilter === null)
            throw new Error("The parameter 'referenceTypeGroupFilter' cannot be null.");
        else if (referenceTypeGroupFilter !== undefined)
            url_ += "ReferenceTypeGroupFilter=" + encodeURIComponent("" + referenceTypeGroupFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllReferenceTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllReferenceTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTeamReferenceTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTeamReferenceTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllReferenceTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTeamReferenceTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTeamReferenceTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTeamReferenceTypeLookupTableDto>(<any>null);
    } 
}

export class PagedResultDtoOfTeamReferenceTypeLookupTableDto
    implements IPagedResultDtoOfTeamReferenceTypeLookupTableDto {
    totalCount!: number;
    items!: TeamReferenceTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTeamReferenceTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(
                        TeamReferenceTypeLookupTableDto.fromJS(item)
                    );
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTeamReferenceTypeLookupTableDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfTeamReferenceTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTeamReferenceTypeLookupTableDto {
    totalCount: number;
    items: TeamReferenceTypeLookupTableDto[] | undefined;
}

export class TeamReferenceTypeLookupTableDto
    implements ITeamReferenceTypeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ITeamReferenceTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): TeamReferenceTypeLookupTableDto {
        data = typeof data === "object" ? data : {};
        let result = new TeamReferenceTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ITeamReferenceTypeLookupTableDto {
    id: number;
    displayName: string | undefined;
}
export interface ITeamSysStatusLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfTeamSysStatusLookupTableDto
    implements IPagedResultDtoOfTeamSysStatusLookupTableDto {
    totalCount!: number;
    items!: TeamSysStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTeamSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TeamSysStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTeamSysStatusLookupTableDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfTeamSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTeamSysStatusLookupTableDto {
    totalCount: number;
    items: TeamSysStatusLookupTableDto[] | undefined;
}

export class TeamSysStatusLookupTableDto
    implements ITeamSysStatusLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ITeamSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): TeamSysStatusLookupTableDto {
        data = typeof data === "object" ? data : {};
        let result = new TeamSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}


export class TeamDto implements ITeamDto {
    name!: string | undefined;
    description!: string | undefined;
    isActive!: boolean;
    remark!: string | undefined;
    sysStatusId!: number | undefined;
    referenceTypeId!: number | undefined;
    id!: number;

    constructor(data?: ITeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.isActive = data["isActive"];
            this.remark = data["remark"];
            this.sysStatusId = data["sysStatusId"];
            this.referenceTypeId = data["referenceTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["remark"] = this.remark;
        data["sysStatusId"] = this.sysStatusId;
        data["referenceTypeId"] = this.referenceTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITeamDto {
    name: string | undefined;
    description: string | undefined;
    isActive: boolean;
    remark: string | undefined;
    sysStatusId: number | undefined;
    referenceTypeId: number | undefined;
    id: number;
}

export class GetTeamForViewDto implements IGetTeamForViewDto {
    team!: TeamDto;
    sysStatusName!: string | undefined;
    referenceTypeName!: string | undefined;

    constructor(data?: IGetTeamForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.team = data["team"] ? TeamDto.fromJS(data["team"]) : <any>undefined;
            this.sysStatusName = data["sysStatusName"];
            this.referenceTypeName = data["referenceTypeName"];
        }
    }

    static fromJS(data: any): GetTeamForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTeamForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["team"] = this.team ? this.team.toJSON() : <any>undefined;
        data["sysStatusName"] = this.sysStatusName;
        data["referenceTypeName"] = this.referenceTypeName;
        return data; 
    }
}

export interface IGetTeamForViewDto {
    team: TeamDto;
    sysStatusName: string | undefined;
    referenceTypeName: string | undefined;
}

export class PagedResultDtoOfGetTeamForViewDto implements IPagedResultDtoOfGetTeamForViewDto {
    totalCount!: number;
    items!: GetTeamForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTeamForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTeamForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTeamForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTeamForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetTeamForViewDto {
    totalCount: number;
    items: GetTeamForViewDto[] | undefined;
}

export class CreateOrEditTeamDto implements ICreateOrEditTeamDto {
    name!: string | undefined;
    description!: string | undefined;
    isActive!: boolean;
    remark!: string | undefined;
    sysStatusId!: number | undefined;
    referenceTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.isActive = data["isActive"];
            this.remark = data["remark"];
            this.sysStatusId = data["sysStatusId"];
            this.referenceTypeId = data["referenceTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["remark"] = this.remark;
        data["sysStatusId"] = this.sysStatusId;
        data["referenceTypeId"] = this.referenceTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditTeamDto {
    name: string | undefined;
    description: string | undefined;
    isActive: boolean;
    remark: string | undefined;
    sysStatusId: number | undefined;
    referenceTypeId: number | undefined;
    id: number | undefined;
}

export class GetTeamForEditOutput implements IGetTeamForEditOutput {
    team!: CreateOrEditTeamDto;
    sysStatusName!: string | undefined;
    referenceTypeName!: string | undefined;

    constructor(data?: IGetTeamForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.team = data["team"] ? CreateOrEditTeamDto.fromJS(data["team"]) : <any>undefined;
            this.sysStatusName = data["sysStatusName"];
            this.referenceTypeName = data["referenceTypeName"];
        }
    }

    static fromJS(data: any): GetTeamForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTeamForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["team"] = this.team ? this.team.toJSON() : <any>undefined;
        data["sysStatusName"] = this.sysStatusName;
        data["referenceTypeName"] = this.referenceTypeName;
        return data; 
    }
}

export interface IGetTeamForEditOutput {
    team: CreateOrEditTeamDto;
    sysStatusName: string | undefined;
    referenceTypeName: string | undefined;
}
//#endregion

//#region Team Member
@Injectable()
export class TeamMembersCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    
    /**
     * @param filter (optional) 
     * @param remarkFilter (optional) 
     * @param maxReportingTeamMemberIdFilter (optional) 
     * @param minReportingTeamMemberIdFilter (optional) 
     * @param teamNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sysRefTenantIdFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @param reportingTeamMemberIdFilter (optional) 
     * @param teamIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, remarkFilter: string | undefined, maxReportingTeamMemberIdFilter: number | undefined, minReportingTeamMemberIdFilter: number | undefined, teamNameFilter: string | undefined, userNameFilter: string | undefined, sysRefTenantIdFilter: string | undefined, sysStatusNameFilter: string | undefined, reportingTeamMemberIdFilter: number | undefined, teamIdFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTeamMemberForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TeamMembers/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (maxReportingTeamMemberIdFilter === null)
            throw new Error("The parameter 'maxReportingTeamMemberIdFilter' cannot be null.");
        else if (maxReportingTeamMemberIdFilter !== undefined)
            url_ += "MaxReportingTeamMemberIdFilter=" + encodeURIComponent("" + maxReportingTeamMemberIdFilter) + "&"; 
        if (minReportingTeamMemberIdFilter === null)
            throw new Error("The parameter 'minReportingTeamMemberIdFilter' cannot be null.");
        else if (minReportingTeamMemberIdFilter !== undefined)
            url_ += "MinReportingTeamMemberIdFilter=" + encodeURIComponent("" + minReportingTeamMemberIdFilter) + "&"; 
        if (teamNameFilter === null)
            throw new Error("The parameter 'teamNameFilter' cannot be null.");
        else if (teamNameFilter !== undefined)
            url_ += "TeamNameFilter=" + encodeURIComponent("" + teamNameFilter) + "&"; 
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sysRefTenantIdFilter === null)
            throw new Error("The parameter 'sysRefTenantIdFilter' cannot be null.");
        else if (sysRefTenantIdFilter !== undefined)
            url_ += "SysRefTenantIdFilter=" + encodeURIComponent("" + sysRefTenantIdFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        if (reportingTeamMemberIdFilter === null)
            throw new Error("The parameter 'reportingTeamMemberIdFilter' cannot be null.");
        else if (reportingTeamMemberIdFilter !== undefined)
            url_ += "ReportingTeamMemberIdFilter=" + encodeURIComponent("" + reportingTeamMemberIdFilter) + "&"; 
        if (teamIdFilter === null)
            throw new Error("The parameter 'teamIdFilter' cannot be null.");
        else if (teamIdFilter !== undefined)
            url_ += "TeamIdFilter=" + encodeURIComponent("" + teamIdFilter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTeamMemberForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTeamMemberForViewDto>><any>_observableThrow(response_);
        }));
    }
    
    /**
     * @param filter (optional)
     * @param remarkFilter (optional)
     * @param maxReportingTeamMemberIdFilter (optional)
     * @param minReportingTeamMemberIdFilter (optional)
     * @param teamNameFilter (optional)
     * @param userNameFilter (optional)
     * @param sysRefTenantIdFilter (optional)
     * @param sysStatusNameFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getTeamMembers(
        filter: string | undefined,
        remarkFilter: string | undefined,
        reportingTeamMemberIdFilter: number | undefined,
        teamIdFilter: number | undefined,
        userNameFilter: string | undefined,
        sysRefTenantIdFilter: string | undefined,
        sysStatusNameFilter: string | undefined,
        sorting: string | undefined
    ): Observable<PagedResultDtoOfGetTeamMemberForViewDto> {
        let url_ =
            this.baseUrl + "/api/services/app/CommonQuery/getTeamMembers?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ +=
                "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&";
        if (reportingTeamMemberIdFilter === null)
            throw new Error(
                "The parameter 'reportingTeamMemberIdFilter' cannot be null."
            );
        else if (reportingTeamMemberIdFilter !== undefined)
            url_ +=
                "ReportingTeamMemberIdFilter=" +
                encodeURIComponent("" + reportingTeamMemberIdFilter) +
                "&";
        if (teamIdFilter === null)
            throw new Error("The parameter 'teamIdFilter' cannot be null.");
        else if (teamIdFilter !== undefined)
            url_ +=
                "TeamIdFilter=" + encodeURIComponent("" + teamIdFilter) + "&";
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ +=
                "UserNameFilter=" +
                encodeURIComponent("" + userNameFilter) +
                "&";
        if (sysRefTenantIdFilter === null)
            throw new Error(
                "The parameter 'sysRefTenantIdFilter' cannot be null."
            );
        else if (sysRefTenantIdFilter !== undefined)
            url_ +=
                "SysRefTenantIdFilter=" +
                encodeURIComponent("" + sysRefTenantIdFilter) +
                "&";
        if (sysStatusNameFilter === null)
            throw new Error(
                "The parameter 'sysStatusNameFilter' cannot be null."
            );
        else if (sysStatusNameFilter !== undefined)
            url_ +=
                "SysStatusNameFilter=" +
                encodeURIComponent("" + sysStatusNameFilter) +
                "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetAll(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetAll(<any>response_);
                        } catch (e) {
                            return <
                                Observable<
                                    PagedResultDtoOfGetTeamMemberForViewDto
                                >
                            >(<any>_observableThrow(e));
                        }
                    } else
                        return <
                            Observable<PagedResultDtoOfGetTeamMemberForViewDto>
                        >(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetAll(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfGetTeamMemberForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfGetTeamMemberForViewDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfGetTeamMemberForViewDto>(
            <any>null
        );
    }

   /**
     * @param id (optional) 
     * @return Success
     */
    getTeamMemberForView(id: number | undefined): Observable<GetTeamMemberForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TeamMembers/GetTeamMemberForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeamMemberForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeamMemberForView(<any>response_);
                } catch (e) {
                    return <Observable<GetTeamMemberForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTeamMemberForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTeamMemberForView(response: HttpResponseBase): Observable<GetTeamMemberForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTeamMemberForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTeamMemberForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTeamMemberForEdit(id: number | undefined): Observable<GetTeamMemberForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TeamMembers/GetTeamMemberForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeamMemberForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeamMemberForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTeamMemberForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTeamMemberForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTeamMemberForEdit(response: HttpResponseBase): Observable<GetTeamMemberForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTeamMemberForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTeamMemberForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTeamMemberDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TeamMembers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TeamMembers/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param remarkFilter (optional) 
     * @param maxReportingTeamMemberIdFilter (optional) 
     * @param minReportingTeamMemberIdFilter (optional) 
     * @param teamNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sysRefTenantIdFilter (optional) 
     * @param sysStatusNameFilter (optional) 
     * @return Success
     */
    getTeamMembersToExcel(filter: string | undefined, remarkFilter: string | undefined, maxReportingTeamMemberIdFilter: number | undefined, minReportingTeamMemberIdFilter: number | undefined, teamNameFilter: string | undefined, userNameFilter: string | undefined, sysRefTenantIdFilter: string | undefined, sysStatusNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TeamMembers/GetTeamMembersToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (maxReportingTeamMemberIdFilter === null)
            throw new Error("The parameter 'maxReportingTeamMemberIdFilter' cannot be null.");
        else if (maxReportingTeamMemberIdFilter !== undefined)
            url_ += "MaxReportingTeamMemberIdFilter=" + encodeURIComponent("" + maxReportingTeamMemberIdFilter) + "&"; 
        if (minReportingTeamMemberIdFilter === null)
            throw new Error("The parameter 'minReportingTeamMemberIdFilter' cannot be null.");
        else if (minReportingTeamMemberIdFilter !== undefined)
            url_ += "MinReportingTeamMemberIdFilter=" + encodeURIComponent("" + minReportingTeamMemberIdFilter) + "&"; 
        if (teamNameFilter === null)
            throw new Error("The parameter 'teamNameFilter' cannot be null.");
        else if (teamNameFilter !== undefined)
            url_ += "TeamNameFilter=" + encodeURIComponent("" + teamNameFilter) + "&"; 
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sysRefTenantIdFilter === null)
            throw new Error("The parameter 'sysRefTenantIdFilter' cannot be null.");
        else if (sysRefTenantIdFilter !== undefined)
            url_ += "SysRefTenantIdFilter=" + encodeURIComponent("" + sysRefTenantIdFilter) + "&"; 
        if (sysStatusNameFilter === null)
            throw new Error("The parameter 'sysStatusNameFilter' cannot be null.");
        else if (sysStatusNameFilter !== undefined)
            url_ += "SysStatusNameFilter=" + encodeURIComponent("" + sysStatusNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeamMembersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeamMembersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTeamMembersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTeamForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTeamMemberTeamLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TeamMembers/GetAllTeamForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeamForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeamForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTeamMemberTeamLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTeamMemberTeamLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTeamForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTeamMemberTeamLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTeamMemberTeamLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTeamMemberTeamLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTeamMemberUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TeamMembers/GetAllUserForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTeamMemberUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTeamMemberUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTeamMemberUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTeamMemberUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTeamMemberUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysRefForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTeamMemberSysRefLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TeamMembers/GetAllSysRefForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysRefForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysRefForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTeamMemberSysRefLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTeamMemberSysRefLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysRefForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTeamMemberSysRefLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTeamMemberSysRefLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTeamMemberSysRefLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSysStatusForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTeamMemberSysStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TeamMembers/GetAllSysStatusForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTeamMemberSysStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTeamMemberSysStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSysStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTeamMemberSysStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTeamMemberSysStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTeamMemberSysStatusLookupTableDto>(<any>null);
    }
}

export class PagedResultDtoOfGetTeamMemberForViewDto
    implements IPagedResultDtoOfGetTeamMemberForViewDto {
    totalCount!: number;
    items!: GetTeamMemberForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTeamMemberForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTeamMemberForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTeamMemberForViewDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfGetTeamMemberForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetTeamMemberForViewDto {
    totalCount: number;
    items: GetTeamMemberForViewDto[] | undefined;
}

export class GetTeamMemberForViewDto implements IGetTeamMemberForViewDto {
    teamMember!: TeamMemberDto;
    teamName!: string | undefined;
    userName!: string | undefined;
    sysRefTenantId!: string | undefined;
    sysStatusName!: string | undefined;
    profilePicture!: string | undefined;
    fullName!: string | undefined;
    profilePictureId!: string | undefined;
    selectedRoleName!: string | undefined;
    emailAddress!: string | undefined;

    constructor(data?: IGetTeamMemberForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.teamMember = data["teamMember"] ? TeamMemberDto.fromJS(data["teamMember"]) : <any>undefined;
            this.teamName = data["teamName"];
            this.userName = data["userName"];
            this.sysRefTenantId = data["sysRefTenantId"];
            this.sysStatusName = data["sysStatusName"];
            this.profilePicture = data["profilePicture"];
            this.fullName = data["fullName"];
            this.profilePictureId = data["profilePictureId"];
            this.selectedRoleName = data["selectedRoleName"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): GetTeamMemberForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTeamMemberForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teamMember"] = this.teamMember ? this.teamMember.toJSON() : <any>undefined;
        data["teamName"] = this.teamName;
        data["userName"] = this.userName;
        data["sysRefTenantId"] = this.sysRefTenantId;
        data["sysStatusName"] = this.sysStatusName;
        data["profilePicture"] = this.profilePicture;
        data["fullName"] = this.fullName;
        data["profilePictureId"] = this.profilePictureId;
        data["selectedRoleName"] = this.selectedRoleName;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export class TeamMemberDto implements ITeamMemberDto {
    remark!: string | undefined;
    reportingTeamMemberId!: number;
    teamId!: number | undefined;
    userId!: number | undefined;
    sysRefId!: number | undefined;
    sysStatusId!: number | undefined;
    roleOrderNumber!: number;
    selectedTeamRoleName!: string | undefined;
    id!: number;

    constructor(data?: ITeamMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.remark = data["remark"];
            this.reportingTeamMemberId = data["reportingTeamMemberId"];
            this.teamId = data["teamId"];
            this.userId = data["userId"];
            this.sysRefId = data["sysRefId"];
            this.sysStatusId = data["sysStatusId"];
            this.roleOrderNumber = data["roleOrderNumber"];
            this.selectedTeamRoleName = data["selectedTeamRoleName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TeamMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remark"] = this.remark;
        data["reportingTeamMemberId"] = this.reportingTeamMemberId;
        data["teamId"] = this.teamId;
        data["userId"] = this.userId;
        data["sysRefId"] = this.sysRefId;
        data["sysStatusId"] = this.sysStatusId;
        data["roleOrderNumber"] = this.roleOrderNumber;
        data["selectedTeamRoleName"] = this.selectedTeamRoleName;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITeamMemberDto {
    remark: string | undefined;
    reportingTeamMemberId: number;
    teamId: number | undefined;
    userId: number | undefined;
    sysRefId: number | undefined;
    sysStatusId: number | undefined;
    roleOrderNumber: number;
    selectedTeamRoleName: string | undefined;
    id: number;
}
export interface IGetTeamMemberForViewDto {
    teamMember: TeamMemberDto;
    teamName: string | undefined;
    userName: string | undefined;
    sysRefTenantId: string | undefined;
    sysStatusName: string | undefined;
    profilePicture: string | undefined;
    fullName: string | undefined;
    profilePictureId: string | undefined;
    selectedRoleName: string | undefined;
    emailAddress: string | undefined;
}

export interface IPagedResultDtoOfGetTeamMemberForViewDto {
    totalCount: number;
    items: GetTeamMemberForViewDto[] | undefined;
}

export class CreateOrEditTeamMemberDto implements ICreateOrEditTeamMemberDto {
    remark!: string | undefined;
    reportingTeamMemberId!: number;
    teamId!: number | undefined;
    userId!: number | undefined;
    sysRefId!: number | undefined;
    sysStatusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTeamMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.remark = data["remark"];
            this.reportingTeamMemberId = data["reportingTeamMemberId"];
            this.teamId = data["teamId"];
            this.userId = data["userId"];
            this.sysRefId = data["sysRefId"];
            this.sysStatusId = data["sysStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTeamMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTeamMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remark"] = this.remark;
        data["reportingTeamMemberId"] = this.reportingTeamMemberId;
        data["teamId"] = this.teamId;
        data["userId"] = this.userId;
        data["sysRefId"] = this.sysRefId;
        data["sysStatusId"] = this.sysStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditTeamMemberDto {
    remark: string | undefined;
    reportingTeamMemberId: number;
    teamId: number | undefined;
    userId: number | undefined;
    sysRefId: number | undefined;
    sysStatusId: number | undefined;
    id: number | undefined;
}

export class GetTeamMemberForEditOutput implements IGetTeamMemberForEditOutput {
    teamMember!: CreateOrEditTeamMemberDto;
    teamName!: string | undefined;
    userName!: string | undefined;
    sysRefTenantId!: string | undefined;
    sysStatusName!: string | undefined;

    constructor(data?: IGetTeamMemberForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.teamMember = data["teamMember"] ? CreateOrEditTeamMemberDto.fromJS(data["teamMember"]) : <any>undefined;
            this.teamName = data["teamName"];
            this.userName = data["userName"];
            this.sysRefTenantId = data["sysRefTenantId"];
            this.sysStatusName = data["sysStatusName"];
        }
    }

    static fromJS(data: any): GetTeamMemberForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTeamMemberForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teamMember"] = this.teamMember ? this.teamMember.toJSON() : <any>undefined;
        data["teamName"] = this.teamName;
        data["userName"] = this.userName;
        data["sysRefTenantId"] = this.sysRefTenantId;
        data["sysStatusName"] = this.sysStatusName;
        return data; 
    }
}

export interface IGetTeamMemberForEditOutput {
    teamMember: CreateOrEditTeamMemberDto;
    teamName: string | undefined;
    userName: string | undefined;
    sysRefTenantId: string | undefined;
    sysStatusName: string | undefined;
}

export class TeamMemberTeamLookupTableDto implements ITeamMemberTeamLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ITeamMemberTeamLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): TeamMemberTeamLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamMemberTeamLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ITeamMemberTeamLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfTeamMemberTeamLookupTableDto implements IPagedResultDtoOfTeamMemberTeamLookupTableDto {
    totalCount!: number;
    items!: TeamMemberTeamLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTeamMemberTeamLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TeamMemberTeamLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTeamMemberTeamLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTeamMemberTeamLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTeamMemberTeamLookupTableDto {
    totalCount: number;
    items: TeamMemberTeamLookupTableDto[] | undefined;
}

export class TeamMemberUserLookupTableDto implements ITeamMemberUserLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ITeamMemberUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): TeamMemberUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamMemberUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ITeamMemberUserLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfTeamMemberUserLookupTableDto implements IPagedResultDtoOfTeamMemberUserLookupTableDto {
    totalCount!: number;
    items!: TeamMemberUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTeamMemberUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TeamMemberUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTeamMemberUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTeamMemberUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTeamMemberUserLookupTableDto {
    totalCount: number;
    items: TeamMemberUserLookupTableDto[] | undefined;
}

export class TeamMemberSysRefLookupTableDto implements ITeamMemberSysRefLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ITeamMemberSysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): TeamMemberSysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamMemberSysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ITeamMemberSysRefLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfTeamMemberSysRefLookupTableDto implements IPagedResultDtoOfTeamMemberSysRefLookupTableDto {
    totalCount!: number;
    items!: TeamMemberSysRefLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTeamMemberSysRefLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TeamMemberSysRefLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTeamMemberSysRefLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTeamMemberSysRefLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTeamMemberSysRefLookupTableDto {
    totalCount: number;
    items: TeamMemberSysRefLookupTableDto[] | undefined;
}

export class TeamMemberSysStatusLookupTableDto implements ITeamMemberSysStatusLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ITeamMemberSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): TeamMemberSysStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamMemberSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ITeamMemberSysStatusLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class PagedResultDtoOfTeamMemberSysStatusLookupTableDto implements IPagedResultDtoOfTeamMemberSysStatusLookupTableDto {
    totalCount!: number;
    items!: TeamMemberSysStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTeamMemberSysStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TeamMemberSysStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTeamMemberSysStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTeamMemberSysStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTeamMemberSysStatusLookupTableDto {
    totalCount: number;
    items: TeamMemberSysStatusLookupTableDto[] | undefined;
}

//#endregion

//#region User Profiles
@Injectable()
export class UserCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(API_BASE_CUSTOM_URL) baseUrl?: string
    ) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getUserTeamProfiles(
        role: number | undefined,
        teamId: number | undefined,
        isSelected: boolean | undefined,
        sorting: string | undefined
    ): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonQuery/GetUserTeamProfiles?";
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (teamId === null)
            throw new Error("The parameter 'teamId' cannot be null.");
        else if (teamId !== undefined)
            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&";
        if (isSelected === null)
            throw new Error("The parameter 'isSelected' cannot be null.");
        else if (isSelected !== undefined)
            url_ += "isSelected=" + encodeURIComponent("" + isSelected) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";

        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUserProfiles(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUserProfiles(<any>response_);
                        } catch (e) {
                            return <Observable<PagedResultDtoOfUserListDto>>(
                                (<any>_observableThrow(e))
                            );
                        }
                    } else
                        return <Observable<PagedResultDtoOfUserListDto>>(
                            (<any>_observableThrow(response_))
                        );
                })
            );
    }

    GetUserTeamProfilesByReportingTeamMember(
        role: number | undefined,
        teamId: number | undefined,
        isSelected: boolean | undefined,
        reportingTeamMemberIdFilter: number | undefined,
        sorting: string | undefined
    ): Observable<PagedResultDtoOfUserListDto> {
        let url_ =
            this.baseUrl +
            "/api/services/app/User/GetUserTeamProfilesByReportingTeamMember?";
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (teamId === null)
            throw new Error("The parameter 'teamId' cannot be null.");
        else if (teamId !== undefined)
            url_ += "teamId=" + encodeURIComponent("" + teamId) + "&";
        if (isSelected === null)
            throw new Error("The parameter 'isSelected' cannot be null.");
        else if (isSelected !== undefined)
            url_ += "isSelected=" + encodeURIComponent("" + isSelected) + "&";
        if (reportingTeamMemberIdFilter === null)
            throw new Error(
                "The parameter 'reportingTeamMemberIdFilter' cannot be null."
            );
        else if (reportingTeamMemberIdFilter !== undefined)
            url_ +=
                "ReportingTeamMemberIdFilter=" +
                encodeURIComponent("" + reportingTeamMemberIdFilter) +
                "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";

        console.log(url_);
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                Accept: "text/plain"
            })
        };

        return this.http
            .request("get", url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUserProfiles(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUserProfiles(<any>response_);
                        } catch (e) {
                            return <Observable<PagedResultDtoOfUserListDto>>(
                                (<any>_observableThrow(e))
                            );
                        }
                    } else
                        return <Observable<PagedResultDtoOfUserListDto>>(
                            (<any>_observableThrow(response_))
                        );
                })
            );
    }

    protected processGetUserProfiles(
        response: HttpResponseBase
    ): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (<any>response).error instanceof Blob
                ? (<any>response).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 =
                        _responseText === ""
                            ? null
                            : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PagedResultDtoOfUserListDto.fromJS(
                        resultData200
                    );
                    return _observableOf(result200);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException(
                        "An unexpected server error occurred.",
                        status,
                        _responseText,
                        _headers
                    );
                })
            );
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }
}

export class PagedResultDtoOfUserListDto
    implements IPagedResultDtoOfUserListDto {
    totalCount!: number;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === "object" ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items) data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean;
    creationTime!: moment.Moment;
    id!: number;
    profilePicture!: string | undefined;
    teamMemberId!: number | undefined;
    selectedRole!: number | undefined;
    reportingTo!: number | undefined;
    roleOrderNumber!: number | undefined;
    selectedTeamRoleName!: string | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (Array.isArray(data["roles"])) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"]
                ? moment(data["creationTime"].toString())
                : <any>undefined;
            this.id = data["id"];
            this.profilePicture = data["profilePicture"];
            this.teamMemberId = data["teamMemberId"];
            this.selectedRole = data["selectedRole"];
            this.reportingTo = data["reportingTo"];
            this.roleOrderNumber = data["roleOrderNumber"];
            this.selectedTeamRoleName = data["selectedTeamRoleName"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === "object" ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles) data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime
            ? this.creationTime.toISOString()
            : <any>undefined;
        data["id"] = this.id;
        data["profilePicture"] = this.profilePicture;
        data["teamMemberId"] = this.teamMemberId;
        data["selectedRole"] = this.selectedRole;
        data["reportingTo"] = this.reportingTo;
        data["roleOrderNumber"] = this.roleOrderNumber;
        data["selectedTeamRoleName"] = this.selectedTeamRoleName;
        return data;
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    id: number;
    profilePicture: string | undefined;
    teamMemberId: number | undefined;
    selectedRole: number | undefined;
    reportingTo: number | undefined;
    roleOrderNumber: number | undefined;
    selectedTeamRoleName: string | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === "object" ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;
}

//#endregion

//#region Web Logs & Misc
export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["latestWebLogLines"])) {
                this.latestWebLogLines = [] as any;
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === "object" ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        if (Array.isArray(this.latestWebLogLines)) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class AdditionalData implements IAdditionalData {
    paypal!: { [key: string]: string };
    stripe!: { [key: string]: string };

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {} as any;
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal![key] = data["Paypal"][key];
                }
            }
            if (data["Stripe"]) {
                this.stripe = {} as any;
                for (let key in data["Stripe"]) {
                    if (data["Stripe"].hasOwnProperty(key))
                        this.stripe![key] = data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === "object" ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    data["Stripe"][key] = this.stripe[key];
            }
        }
        return data;
    }
}

export interface IAdditionalData {
    paypal: { [key: string]: string };
    stripe: { [key: string]: string };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(
        message: string,
        status: number,
        response: string,
        headers: { [key: string]: any },
        result: any
    ) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result?: any
): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(
            new ApiException(message, status, response, headers, null)
        );
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === "object" ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === "object" ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}
//#endregion
